using PythonCall


"TO DO
elastic     ✅
rot0_2      ✅
rot0_4      ✅
rot0_6      ✅
rot0_8      ✅
vib0_1      ✅
vib0_2
vib0_3
vib0_4
vib0_5
vib0_6
vib0_7
a3sup
b3pg
w3du
bp3sum
ap1sum
w1du
e3sgp
ab1sgp
a1pg
c3pu
bp1sup
cp1sup
cp3pu
d3sup
f3pu
g3pu
M1M2
o1pu
dissociation
ionx2sgp
iona2pu
ionb2sup
dion
ddion
"

function e_N2elastic(E)
    cross_section = Vector{Float64}(undef, length(E))
    for ie in eachindex(E)
        if (E[ie] >= 1) & (E[ie] .< 1.733)
            cross_section[ie] = exp(-34.56132 + 0.9475102 * log(E[ie]) - 4.235151 * log(E[ie])^2 + 6.523666 * log(E[ie])^3)
        elseif (E[ie] >= 1.733) & (E[ie] .< 2.006)
            cross_section[ie] = exp(9.113062 - 242.3374 * log(E[ie]) + 441.5981 * log(E[ie])^2 - 262.3439 * log(E[ie])^3)
        elseif (E[ie] >= 2.006) & (E[ie] .< 2.317)
            cross_section[ie] = exp(72.26128 - 455.1942 * log(E[ie]) + 642.8157 * log(E[ie])^2 - 299.3418 * log(E[ie])^3)
        elseif (E[ie] >= 2.317) & (E[ie] .< 2.554)
            cross_section[ie] = exp(1767.169 - 6203.92 * log(E[ie]) + 7114.73 * log(E[ie])^2 - 2716.333 * log(E[ie])^3)
        elseif (E[ie] >= 2.554) & (E[ie] .< 2.775)
            cross_section[ie] = exp(867.3897 - 2850.537 * log(E[ie]) + 3000.209 * log(E[ie])^2 - 1050.929 * log(E[ie])^3)
        elseif (E[ie] >= 2.775) & (E[ie] .< 2.981)
            cross_section[ie] = exp(679.3589 - 2066.956 * log(E[ie]) + 1995.594 * log(E[ie])^2 - 641.9862 * log(E[ie])^3)
        elseif (E[ie] >= 2.981) & (E[ie] .< 3.215)
            cross_section[ie] = exp(-400.2765 + 865.4071 * log(E[ie]) - 668.1613 * log(E[ie])^2 + 167.3741 * log(E[ie])^3)
        elseif (E[ie] >= 3.215) & (E[ie] .< 3.457)
            cross_section[ie] = exp(1815.893 - 4716.509 * log(E[ie]) + 4004.182 * log(E[ie])^2 - 1132.109 * log(E[ie])^3)
        elseif (E[ie] >= 3.457) & (E[ie] .< 4.33)
            cross_section[ie] = exp(45.31069 - 184.5681 * log(E[ie]) + 142.8378 * log(E[ie])^2 - 36.88586 * log(E[ie])^3)
        elseif (E[ie] >= 4.33) & (E[ie] .< 1000)
            cross_section[ie] = exp(-35.26294 + 0.8019902 * log(E[ie]) - 0.202546 * log(E[ie])^2 + 0.007484 * log(E[ie])^3)
        elseif E[ie] >= 1000
            cross_section[ie] = 9.234e-14 / E[ie]
        else
            cross_section[ie] = 0
        end
    end
    cross_section .= cross_section ./ 1e4
    return cross_section
end

function e_N2rot0_2(E)
    log10E = [-1.529205842868462, -1.401759744308854, -1.298455005566862,
              -1.229836683674959, -1.107192298263224, -0.930884014999626,
              -0.739165582563789, -0.534726081040409, -0.361197419278502,
              -0.210753800802626, -0.023659016727907, 0.148387783842545,
              0.195027357403972, 0.256843155275395, 0.271309779815279,
              0.284961440170103, 0.292280091257079, 0.313103310290649,
              0.339325032538764, 0.360990712227029, 0.383915274219258,
              0.406241931082478, 0.426693754073074, 0.438007445340180,
              0.442409564564855, 0.449441512598424, 0.461625748593174,
              0.475071834892396, 0.479153568268782, 0.698970004336019,
              1.000000000000000, 1.301029995663981, 1.477121254719663,
              1.698970004336019]

    log10Xs = [-16.489672666179871, -16.255790604873923, -16.087003295315228,
        -15.996264950740080, -15.953203452818123, -15.989191402537488,
        -16.041042208514060, -16.116569595034353, -16.168214419287263,
        -16.193450575738691, -16.195569244896330, -16.150452456808626,
        -16.107709885163285, -16.025430820560523, -15.961620468316118,
        -15.840488804947917, -15.803011086935593, -15.948567729023981,
        -15.533186544559602, -15.883157959631777, -15.476897837253116,
        -15.795237176295828, -15.528433895057361, -15.719342640373487,
        -15.765657146956446, -15.706366402956451, -15.622036628514593,
        -15.639548788652569, -15.655341886713167, -15.511449283499555,
        -15.414539270491499, -15.468521082957746, -15.552841968657781,
        -15.787812395596042]
    # import interpolate function from python
    pyinterpolate = pyimport("scipy.interpolate")
    cross_section = 10 .^ pyinterpolate.PchipInterpolator(log10E, log10Xs)(log10.(E));
    cross_section = 10 .^ [pyinterpolate.PchipInterpolator(log10E, log10Xs)(log10.(E[E .<= 10^log10E[end-1]])),
                pyinterpolate.interp1d(log10E[end-1:end], log10Xs[end-1:end], kind="linear", fill_value="extrapolate")(log10.(E[E .>= 10^log10E[end-1]]))]
    # convert from a Python array back to a Julia array
    cross_section = pyconvert.(Array, cross_section)
    # merge the two parts
    cross_section = vcat(cross_section[1], cross_section[2])

    I = findall(.!isfinite.(cross_section))
    cross_section[I] .= 0

    cross_section = cross_section / 1e4

    cross_section[E .> 10] .= 0 #TODO: FIX THIS/BG20190312  # wonder why? /EG20230924
    cross_section[E .< 0.001480105560000] .= 0

    return cross_section
end

function e_N2rot0_4(E)
    log10E = [-1.532680902603447, -1.404874076776330, -1.275825566920618,
              -1.224367870665778, -1.149260425122097, -0.985947211351686,
              -0.834892017817066, -0.642148004931654, -0.267182529393861,
              -0.087071929590095, -0.002885752451284, 0.091967356784349,
              0.160395697309093, 0.195408146635714, 0.219793807440825,
              0.246011772608117, 0.282549189711953, 0.290486080963258,
              0.293629539250526, 0.298637983878642, 0.305483198238818,
              0.311674551718697, 0.316057534684070, 0.322827300608398,
              0.327398396418622, 0.335001803552344, 0.340464631369559,
              0.347584582685744, 0.361414574811236, 0.368229005640144,
              0.377677383680488, 0.380158540333515, 0.382076382389718,
              0.384787439246178, 0.397755986770893, 0.401409239603281,
              0.406827163211131, 0.409948376785994, 0.418183570165017,
              0.422882192428233, 0.426271155084866, 0.428770588446716,
              0.440721896378690, 0.443789449978017, 0.447612136905164,
              0.460363315178215, 0.464043471225615, 0.479034714667705,
              0.698970004336019, 1.000000000000000, 1.301029995663981,
              1.477121254719663, 1.698970004336019]

    log10Xs = [-17.306560217472983, -16.905296630034872, -16.496472163619632,
               -16.346950305478465, -16.302769455158653, -16.372165876080111,
               -16.426413029943376, -16.531167125488427, -16.790591014528083,
               -16.912714248287095, -16.943688489526014, -16.912239953864546,
               -16.800436413819938, -16.590216924422101, -16.405144814674895,
               -16.102766217156070, -15.589673466968044, -15.508545593737043,
               -15.500300448742312, -15.580114743299788, -15.801601894983513,
               -15.947592289811023, -15.842459615546449, -15.608113401394665,
               -15.373307955548082, -15.245568441986372, -15.205532305410159,
               -15.427135164359850, -15.943514591785419, -15.680492955101307,
               -15.223843323199201, -15.176424582771727, -15.160459552129517,
               -15.186373523082741, -15.698794908820723, -15.795806879885383,
               -15.851026564276077, -15.807316835052490, -15.432362387183495,
               -15.326658892601827, -15.300812117955953, -15.324945790826710,
               -15.784820589642830, -15.844461318346980, -15.785259390571994,
               -15.519190930094789, -15.490189382908351, -15.625025350388160,
               -15.804100347590765, -15.931814138253838, -16.080921907623924,
               -15.903089986991944, -15.860120913598763]

    pyinterpolate = pyimport_conda("scipy.interpolate", "scipy");
    cross_section = 10 .^ pyinterpolate.PchipInterpolator(log10E, log10Xs)(log10.(E));
    I = findall(.!isfinite.(cross_section))
    cross_section[I] .= 0

    cross_section = cross_section / 1e4

    cross_section[E .> 10] .= 0 #TODO: FIX THIS/BG20190312  # wonder why? /EG20230924
    cross_section[E .< 0.004933884000000] .= 0

    return cross_section
end

function e_N2rot0_6(E)
    log10E = [-1.540835374081948, -1.393951276348084, -1.299408565019692,
              -1.198041825677987, -1.085443481487013, -1.027862686921294,
              -0.853878202151661, -0.718632215072602, -0.500218151334885,
              -0.387657446570351, -0.358603573302421, 1.000000000000000,
              1.301029995663981, 1.477121254719663, 1.698970004336019]

    log10Xs = [-17.463274018565434, -16.993190004022189, -16.664905513524634,
               -16.587790797622958, -16.660806579985472, -16.726677458224287,
               -16.816693087537782, -16.893226274300982, -17.065268564666383,
               -17.141544862344141, -17.151656694256861, -18.154901959985743,
               -17.096910013008056, -16.443697499232712, -16.585026652029178]

    pyinterpolate = pyimport_conda("scipy.interpolate", "scipy");
    cross_section = 10 .^ pyinterpolate.PchipInterpolator(log10E, log10Xs)(log10.(E));
    I = findall(.!isfinite.(cross_section))
    cross_section[I] .= 0

    cross_section = cross_section / 1e4

    cross_section[E .> 10] .= 0 #TODO: FIX THIS/BG20190312  # wonder why? /EG20230924
    cross_section[E .< 0.010361812440000] .= 0

    return cross_section
end

function e_N2rot0_8(E)
    log10E = [-1.528601289020590, -1.426292957506456, -1.329246907900923,
              -1.276205819361377, -1.202716630014793, -1.121888884265058,
              -1.049473630001863, -0.957742617010783, -0.856184155958383,
              -0.785278063101844, -0.658159947064807, -0.576218700202296,
              -0.413581594354676]

    log10Xs = [-17.416103498733147, -17.126710494427051, -16.871536453251654,
               -16.774198368667303, -16.732590449548407, -16.757990427343014,
               -16.809412134822608, -16.874111071306828, -16.930759733883072,
               -16.972370479146925, -17.063587133755963, -17.133072146723649,
               -17.275381828471725]

    pyinterpolate = pyimport_conda("scipy.interpolate", "scipy");
    cross_section = 10 .^ pyinterpolate.PchipInterpolator(log10E, log10Xs)(log10.(E));
    I = findall(.!isfinite.(cross_section))
    cross_section[I] .= 0

    cross_section = cross_section / 1e4

    cross_section[E .> 10] .= 0 #TODO: FIX THIS/BG20190312  # wonder why? /EG20230924
    cross_section[E .< 0.017764640640000] .= 0

    return cross_section
end

function e_N2vib0_1(Ep)
    E = [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
    s = [1e-23, 3e-23, 3.8e-23, 4.2e-23, 4.6e-23, 5.5e-23, 6.7e-23, 8.1e-23]

    E = vcat(E, [1.6, 1.7, 1.75, 1.8, 1.85, 1.9, 1.95, 2, 2.05, 2.1, 2.15, 2.2, 2.23, 2.3, 2.35, 2.4, 2.45, 2.5, 2.55, 2.6, 2.65, 2.73, 2.8, 2.85, 2.9, 3, 3.05, 3.075, 3.14, 3.2, 3.3, 3.4])
    s = vcat(s, [0.28e-20, 0.51e-20, 1.2e-20, 1.9e-20, 2.6e-20, 4.5e-20, 5.7e-20, 4.2e-20, 2.2e-20, 1.4e-20, 2.5e-20, 5.0e-20, 5.8e-20, 4.4e-20, 3.6e-20, 1.9e-20, 1.5e-20, 2.5e-20, 4.5e-20, 3.6e-20, 1.67e-20, 1.21e-20, 2.78e-20, 3.20e-20, 2.04e-20, 0.88e-20, 1.35e-20, 1.92e-20, 1.58e-20, 0.79e-20, 0.97e-20, 0.56e-20])

    E = vcat(E, [5, 7.5, 10, 15, 18, 20, 23, 25, 30, 50, 75])
    s = vcat(s, [6.5e-22, 3.1e-22, 1.4e-22, 4.1e-22, 7.5e-22, 19.4e-22, 12.1e-22, 7.2e-22, 2.4e-22, 1.4e-22, 0.67e-22])

    pyinterpolate = pyimport_conda("scipy.interpolate", "scipy");
    cross_section = exp.([pyinterpolate.PchipInterpolator(E, log.(s))(Ep[Ep .< E[end]]);
               pyinterpolate.interp1d(log.(E), log.(s), kind="linear", fill_value="extrapolate")(log.(Ep[Ep .>= E[end]]))])

    I = findall(.!isfinite.(cross_section))
    cross_section[I] .= 0

    cross_section[Ep .> 10] .= 0 #TODO: FIX THIS/BG20190312  # wonder why? /EG20230924
    cross_section[Ep .< 0.2888] .= 0

    return cross_section
end
