<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · AURORA.jl</title><meta name="title" content="Reference · AURORA.jl"/><meta property="og:title" content="Reference · AURORA.jl"/><meta property="twitter:title" content="Reference · AURORA.jl"/><meta name="description" content="Documentation for AURORA.jl."/><meta property="og:description" content="Documentation for AURORA.jl."/><meta property="twitter:description" content="Documentation for AURORA.jl."/><meta property="og:url" content="https://egavazzi.github.io/AURORA.jl/95-reference/"/><meta property="twitter:url" content="https://egavazzi.github.io/AURORA.jl/95-reference/"/><link rel="canonical" href="https://egavazzi.github.io/AURORA.jl/95-reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AURORA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">AURORA</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../10-manual/05-installation/">Installation</a></li><li><a class="tocitem" href="../10-manual/10-get_started/">Get started</a></li><li><a class="tocitem" href="../10-manual/15-folder_structure/">Folder structure</a></li><li><a class="tocitem" href="../10-manual/20-visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../85-troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../90-api/">API Reference</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/egavazzi/AURORA.jl/blob/main/docs/src/95-reference.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="reference"><a class="docs-heading-anchor" href="#reference">Reference</a><a id="reference-1"></a><a class="docs-heading-anchor-permalink" href="#reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#AURORA.TransportMatrices-NTuple{4, Int64}"><code>AURORA.TransportMatrices</code></a></li><li><a href="#AURORA.TransportMatrices"><code>AURORA.TransportMatrices</code></a></li><li><a href="#AURORA.Crank_Nicolson_optimized!-NTuple{10, Any}"><code>AURORA.Crank_Nicolson_optimized!</code></a></li><li><a href="#AURORA.Ie_with_LET-NTuple{7, Any}"><code>AURORA.Ie_with_LET</code></a></li><li><a href="#AURORA.animate_Ie_in_time"><code>AURORA.animate_Ie_in_time</code></a></li><li><a href="#AURORA.beam_weight-Tuple{Any}"><code>AURORA.beam_weight</code></a></li><li><a href="#AURORA.calculate_cascading_N2"><code>AURORA.calculate_cascading_N2</code></a></li><li><a href="#AURORA.calculate_cascading_N2_quadgk"><code>AURORA.calculate_cascading_N2_quadgk</code></a></li><li><a href="#AURORA.calculate_cascading_O-Tuple{Any, Any}"><code>AURORA.calculate_cascading_O</code></a></li><li><a href="#AURORA.calculate_cascading_O2"><code>AURORA.calculate_cascading_O2</code></a></li><li><a href="#AURORA.calculate_cascading_O2_quadgk"><code>AURORA.calculate_cascading_O2_quadgk</code></a></li><li><a href="#AURORA.calculate_cascading_O_quadgk-Tuple{Any, Any}"><code>AURORA.calculate_cascading_O_quadgk</code></a></li><li><a href="#AURORA.calculate_density_from_Ie!-NTuple{7, Any}"><code>AURORA.calculate_density_from_Ie!</code></a></li><li><a href="#AURORA.calculate_heating_rate-NTuple{6, Any}"><code>AURORA.calculate_heating_rate</code></a></li><li><a href="#AURORA.calculate_iri_data-Tuple{}"><code>AURORA.calculate_iri_data</code></a></li><li><a href="#AURORA.calculate_msis_data-Tuple{}"><code>AURORA.calculate_msis_data</code></a></li><li><a href="#AURORA.calculate_n_loop-NTuple{4, Any}"><code>AURORA.calculate_n_loop</code></a></li><li><a href="#AURORA.calculate_scattered_flux!-NTuple{4, Any}"><code>AURORA.calculate_scattered_flux!</code></a></li><li><a href="#AURORA.calculate_scattering_matrices"><code>AURORA.calculate_scattering_matrices</code></a></li><li><a href="#AURORA.calculate_scattering_matrices_legacy"><code>AURORA.calculate_scattering_matrices_legacy</code></a></li><li><a href="#AURORA.calculate_volume_excitation-NTuple{5, Any}"><code>AURORA.calculate_volume_excitation</code></a></li><li><a href="#AURORA.create_crank_nicolson_nzval_mappings-NTuple{4, Any}"><code>AURORA.create_crank_nicolson_nzval_mappings</code></a></li><li><a href="#AURORA.create_crank_nicolson_sparsity_patterns-NTuple{5, Any}"><code>AURORA.create_crank_nicolson_sparsity_patterns</code></a></li><li><a href="#AURORA.create_steady_state_nzval_mapping-Tuple{Any, Any, Any}"><code>AURORA.create_steady_state_nzval_mapping</code></a></li><li><a href="#AURORA.create_steady_state_sparsity_pattern-NTuple{5, Any}"><code>AURORA.create_steady_state_sparsity_pattern</code></a></li><li><a href="#AURORA.downsampling_fluxes-Tuple{Any, Any}"><code>AURORA.downsampling_fluxes</code></a></li><li><a href="#AURORA.excitation_4278-Tuple{Any}"><code>AURORA.excitation_4278</code></a></li><li><a href="#AURORA.excitation_6730_N2-Tuple{Any}"><code>AURORA.excitation_6730_N2</code></a></li><li><a href="#AURORA.excitation_7774_O-Tuple{Any}"><code>AURORA.excitation_7774_O</code></a></li><li><a href="#AURORA.excitation_7774_O2-Tuple{Any}"><code>AURORA.excitation_7774_O2</code></a></li><li><a href="#AURORA.excitation_8446_O-Tuple{Any}"><code>AURORA.excitation_8446_O</code></a></li><li><a href="#AURORA.excitation_8446_O2-Tuple{Any}"><code>AURORA.excitation_8446_O2</code></a></li><li><a href="#AURORA.excitation_O1D-Tuple{Any}"><code>AURORA.excitation_O1D</code></a></li><li><a href="#AURORA.excitation_O1S-Tuple{Any}"><code>AURORA.excitation_O1S</code></a></li><li><a href="#AURORA.find_Ietop_file-Tuple{Any}"><code>AURORA.find_Ietop_file</code></a></li><li><a href="#AURORA.find_cascading_file-Tuple{Any, Any}"><code>AURORA.find_cascading_file</code></a></li><li><a href="#AURORA.find_iri_file-Tuple{}"><code>AURORA.find_iri_file</code></a></li><li><a href="#AURORA.find_msis_file-Tuple{}"><code>AURORA.find_msis_file</code></a></li><li><a href="#AURORA.find_scattering_matrices"><code>AURORA.find_scattering_matrices</code></a></li><li><a href="#AURORA.get_cross_section-Tuple{Any, Any, Any}"><code>AURORA.get_cross_section</code></a></li><li><a href="#AURORA.initialize_transport_matrices-NTuple{6, Any}"><code>AURORA.initialize_transport_matrices</code></a></li><li><a href="#AURORA.interpolate_O_parameters-Tuple{Any}"><code>AURORA.interpolate_O_parameters</code></a></li><li><a href="#AURORA.interpolate_iri_to_grid-Tuple{Any, Any}"><code>AURORA.interpolate_iri_to_grid</code></a></li><li><a href="#AURORA.interpolate_msis_to_grid-Tuple{Any, Any}"><code>AURORA.interpolate_msis_to_grid</code></a></li><li><a href="#AURORA.interpolate_profile-Tuple{Any, Any, Any}"><code>AURORA.interpolate_profile</code></a></li><li><a href="#AURORA.load_cascading_matrices-Tuple{Any}"><code>AURORA.load_cascading_matrices</code></a></li><li><a href="#AURORA.load_cross_sections-Tuple{Any, Any}"><code>AURORA.load_cross_sections</code></a></li><li><a href="#AURORA.load_electron_densities-Tuple{Any, Any}"><code>AURORA.load_electron_densities</code></a></li><li><a href="#AURORA.load_excitation_threshold-Tuple{}"><code>AURORA.load_excitation_threshold</code></a></li><li><a href="#AURORA.load_iri-Tuple{Any}"><code>AURORA.load_iri</code></a></li><li><a href="#AURORA.load_iri_data-Tuple{Any}"><code>AURORA.load_iri_data</code></a></li><li><a href="#AURORA.load_msis-Tuple{Any}"><code>AURORA.load_msis</code></a></li><li><a href="#AURORA.load_msis_data-Tuple{Any}"><code>AURORA.load_msis_data</code></a></li><li><a href="#AURORA.load_neutral_densities-Tuple{Any, Any}"><code>AURORA.load_neutral_densities</code></a></li><li><a href="#AURORA.load_parameters_iri-Tuple{Any}"><code>AURORA.load_parameters_iri</code></a></li><li><a href="#AURORA.load_parameters_msis-Tuple{Any}"><code>AURORA.load_parameters_msis</code></a></li><li><a href="#AURORA.load_scattering_matrices-Tuple{Any}"><code>AURORA.load_scattering_matrices</code></a></li><li><a href="#AURORA.loss_to_thermal_electrons-Tuple{Real, Any, Any}"><code>AURORA.loss_to_thermal_electrons</code></a></li><li><a href="#AURORA.make_Ie_top_file-Tuple{Any}"><code>AURORA.make_Ie_top_file</code></a></li><li><a href="#AURORA.make_altitude_grid-Tuple{Any, Any}"><code>AURORA.make_altitude_grid</code></a></li><li><a href="#AURORA.make_column_excitation_file-Tuple{Any}"><code>AURORA.make_column_excitation_file</code></a></li><li><a href="#AURORA.make_current_file-Tuple{Any}"><code>AURORA.make_current_file</code></a></li><li><a href="#AURORA.make_density_file-Tuple{Any}"><code>AURORA.make_density_file</code></a></li><li><a href="#AURORA.make_energy_grid-Tuple{Any}"><code>AURORA.make_energy_grid</code></a></li><li><a href="#AURORA.make_heating_rate_file-Tuple{Any}"><code>AURORA.make_heating_rate_file</code></a></li><li><a href="#AURORA.make_savedir-Tuple{Any, Any}"><code>AURORA.make_savedir</code></a></li><li><a href="#AURORA.make_volume_excitation_file-Tuple{Any}"><code>AURORA.make_volume_excitation_file</code></a></li><li><a href="#AURORA.mu_avg-Tuple{Any}"><code>AURORA.mu_avg</code></a></li><li><a href="#AURORA.q2colem"><code>AURORA.q2colem</code></a></li><li><a href="#AURORA.q2colem"><code>AURORA.q2colem</code></a></li><li><a href="#AURORA.rename_if_exists-Tuple{Any}"><code>AURORA.rename_if_exists</code></a></li><li><a href="#AURORA.restructure_streams_of_Ie-Tuple{Any, Any, Any}"><code>AURORA.restructure_streams_of_Ie</code></a></li><li><a href="#AURORA.save_cascading_matrices-NTuple{5, Any}"><code>AURORA.save_cascading_matrices</code></a></li><li><a href="#AURORA.save_iri_data-Tuple{Any, Any}"><code>AURORA.save_iri_data</code></a></li><li><a href="#AURORA.save_msis_data-Tuple{Any, Any}"><code>AURORA.save_msis_data</code></a></li><li><a href="#AURORA.search_existing_iri_file-Tuple{}"><code>AURORA.search_existing_iri_file</code></a></li><li><a href="#AURORA.search_existing_msis_file-Tuple{}"><code>AURORA.search_existing_msis_file</code></a></li><li><a href="#AURORA.setup-NTuple{5, Any}"><code>AURORA.setup</code></a></li><li><a href="#AURORA.steady_state_scheme_optimized!-NTuple{7, Any}"><code>AURORA.steady_state_scheme_optimized!</code></a></li><li><a href="#AURORA.update_crank_nicolson_matrices!-NTuple{13, Any}"><code>AURORA.update_crank_nicolson_matrices!</code></a></li><li><a href="#AURORA.update_matrices!-Tuple{AURORA.TransportMatrices, Vararg{Any, 11}}"><code>AURORA.update_matrices!</code></a></li><li><a href="#AURORA.update_steady_state_matrix!-NTuple{10, Any}"><code>AURORA.update_steady_state_matrix!</code></a></li><li><a href="#AURORA.v_of_E-Tuple{Any}"><code>AURORA.v_of_E</code></a></li><li><a href="#AURORA.validate_θ_lims-Tuple{Any}"><code>AURORA.validate_θ_lims</code></a></li></ul><article><details class="docstring" open="true"><summary id="AURORA.TransportMatrices"><a class="docstring-binding" href="#AURORA.TransportMatrices"><code>AURORA.TransportMatrices</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TransportMatrices</code></pre><p>Container for the matrices used in the electron transport equations.</p><p><strong>Fields</strong></p><ul><li><code>A::Vector{Float64}</code>: Loss term matrix (altitude dimension)</li><li><code>B::Array{Float64, 3}</code>: Scattering term matrix (altitude x angle x angle)</li><li><code>D::Array{Float64, 2}</code>: Diffusion coefficient matrix (energy x angle)</li><li><code>Q::Array{Float64, 3}</code>: Source term array (altitude*angle x time x energy)</li><li><code>Ddiffusion::SparseArrays.SparseMatrixCSC{Float64, Int64}</code>: Diffusion operator (altitude x altitude)</li></ul><p>The struct is mutable to allow efficient in-place updates of Q during the energy cascade.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/matrix_building.jl#L4-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.TransportMatrices-NTuple{4, Int64}"><a class="docstring-binding" href="#AURORA.TransportMatrices-NTuple{4, Int64}"><code>AURORA.TransportMatrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TransportMatrices(n_altitude, n_angle, n_time, n_energy)</code></pre><p>Construct an empty TransportMatrices container with zeros.</p><p><strong>Arguments</strong></p><ul><li><code>n_altitude::Int</code>: Number of altitude grid points</li><li><code>n_angle::Int</code>: Number of angle bins</li><li><code>n_time::Int</code>: Number of time steps</li><li><code>n_energy::Int</code>: Number of energy bins</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/matrix_building.jl#L26-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.Crank_Nicolson_optimized!-NTuple{10, Any}"><a class="docstring-binding" href="#AURORA.Crank_Nicolson_optimized!-NTuple{10, Any}"><code>AURORA.Crank_Nicolson_optimized!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Crank_Nicolson_optimized!(Ie, t, h_atm, μ, v, matrices, iE, Ie_top, I0, cache; first_iteration = false)</code></pre><p>Optimized Crank-Nicolson time-stepping scheme using direct nzval modification. This is an in-place version that modifies <code>Ie</code> directly to avoid allocations.</p><p>On first iteration, creates the sparsity pattern and mapping which are stored in cache. On subsequent iterations, only updates the nzval array directly.</p><p><strong>Mathematical Background</strong></p><p>The time-dependent electron transport equation is:</p><pre><code class="language-julia hljs">∂Ie/∂t + μ*v ∂Ie/∂z + A*Ie - ∫B*Ie&#39;dΩ&#39; - D*∇²Ie = Q</code></pre><p>The Crank-Nicolson scheme uses implicit time-stepping with second-order accuracy:</p><pre><code class="language-julia hljs">(Ie^(n+1) - Ie^n)/Δt = [RHS^(n+1) + RHS^n] / 2</code></pre><p>This leads to two matrices:</p><pre><code class="language-julia hljs">Mlhs * Ie^(n+1) = Mrhs * Ie^n + (Q^(n+1) + Q^n)/2
     ↑                  ↑
Implicit part      Explicit part</code></pre><p>Where:</p><pre><code class="language-julia hljs">Mlhs = Ddt + μ*Ddz/2 + A/2 - B/2 - D*Ddiffusion/2
Mrhs = Ddt - μ*Ddz/2 - A/2 + B/2 + D*Ddiffusion/2</code></pre><p>Both matrices have the same block structure as in steady-state:</p><pre><code class="language-julia hljs">┌─────────┬─────────┬─────────┐
│ Block   │ Block   │ Block   │  Each block is n_z × n_z
│ (1,1)   │ (1,2)   │ (1,3)   │
├─────────┼─────────┼─────────┤
│ Block   │ Block   │ Block   │  Off-diagonal: angular scattering
│ (2,1)   │ (2,2)   │ (2,3)   │
├─────────┼─────────┼─────────┤
│ Block   │ Block   │ Block   │  Diagonal: transport + diffusion
│ (3,1)   │ (3,2)   │ (3,3)   │
└─────────┴─────────┴─────────┘</code></pre><p><strong>Arguments</strong></p><ul><li><code>Ie</code>: pre-allocated output array [m⁻² s⁻¹] (n<em>z * n</em>angle × n_t) to store results</li><li><code>t</code>: time grid [s]</li><li><code>h_atm</code>: altitude grid [km]</li><li><code>μ</code>: cosine of pitch angle grid</li><li><code>v</code>: electron velocity [km/s]</li><li><code>matrices::TransportMatrices</code>: container with<ul><li><code>A</code>: electron loss rate [s⁻¹]</li><li><code>B</code>: scattering matrix [s⁻¹] (n<em>z × n</em>angle × n_angle)</li><li><code>D</code>: pitch-angle diffusion coefficient [s⁻¹] (n_angle,)</li><li><code>Q</code>: source term [m⁻² s⁻¹] at each time step</li><li><code>Ddiffusion</code>: spatial diffusion matrix (n<em>z × n</em>z)</li></ul></li><li><code>iE</code>: current energy index</li><li><code>Ie_top</code>: boundary condition at top [m⁻² s⁻¹] at each time step</li><li><code>I0</code>: initial condition [m⁻² s⁻¹]</li><li><code>cache</code>: Cache object (must have fields for Mlhs, Mrhs, mappings, KLU, diff matrices)</li><li><code>first_iteration</code>: whether this is the first call</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/crank_nicolson_optimized.jl#L447-L513">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.Ie_with_LET-NTuple{7, Any}"><a class="docstring-binding" href="#AURORA.Ie_with_LET-NTuple{7, Any}"><code>AURORA.Ie_with_LET</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Ie_with_LET(E₀, Q, E, dE, μ_center, BeamWeight, Beams; low_energy_tail=true)</code></pre><p>Return an electron spectra following a Maxwellian distribution with a low energy tail (LET)</p><p>This function is a <strong>corrected</strong> implementation of Meier/Strickland/Hecht/Christensen JGR 1989 (pages 13541-13552)</p><p><strong>Arguments</strong></p><ul><li><code>E₀</code>: characteristic energy (eV)</li><li><code>Q</code>: total energy flux into the ionosphere (eV/m²/s)</li><li><code>E</code>: energy grid (eV). Vector [nE]</li><li><code>dE</code>: energy bin sizes(eV). Vector [nE]</li><li><code>μ_center</code>: electron beams average pitch angle cosine. Vector [n_beams]</li><li><code>BeamWeight</code>: weights of the different beams. Vector [n_beams]</li><li><code>Beams</code>: indices of the electron beams with a precipitating flux</li><li><code>low_energy_tail=true</code>: control the presence of a low energy tail</li></ul><p><strong>Returns:</strong></p><ul><li><code>Ie_top</code>: differential electron energy flux (#e⁻/m²/s). Matrix [n_beams, 1, nE]</li></ul><p><strong>Important notes</strong></p><p>This is a corrected version of the equations present in Meier et al. 1989 to match the results presented in Fig. 4 of their paper.<br/>Changes were made to the factor <code>b</code>:</p><ul><li>no inverse</li></ul><p><strong>Examples:</strong></p><p>Calling the function with flux only in the two first beams (0 to 20°) and an &quot;isotropic&quot; pitch-angle distribution.</p><pre><code class="language-julia-repl hljs">julia&gt; E, dE = make_energy_grid(100e3);

julia&gt; θ_lims = 180:-10:0;

julia&gt; μ_center = mu_avg(θ_lims);

julia&gt; BeamWeight = beam_weight(180:-10:0);

julia&gt; Ie = AURORA.Ie_with_LET(1e3, 1e10, E, dE, μ_center, BeamWeight, 1:2);
</code></pre><p>Calling the function with flux only in the three first beams (0 to 30°) and a custom pitch-angle distribution (1/2 of the total flux in the first beam, 1/4 in the second beam and 1/4 in the third beam).</p><pre><code class="language-julia-repl hljs">julia&gt; E, dE = make_energy_grid(100e3);

julia&gt; θ_lims = 180:-10:0;

julia&gt; μ_center = mu_avg(θ_lims);

julia&gt; BeamWeight = [2, 1, 1];

julia&gt; Ie = Ie_with_LET(1e3, 1e10, E, dE, μ_center, BeamWeight, 1:3);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/input_flux.jl#L216-L275">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.animate_Ie_in_time"><a class="docstring-binding" href="#AURORA.animate_Ie_in_time"><code>AURORA.animate_Ie_in_time</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">animate_Ie_in_time(directory_to_process; angles_to_plot=nothing, colorrange=nothing, ...)</code></pre><p>Plot a heatmap of Ie over height and energy, and animate it in time. It will load the result files one by one. The animation will be saved as a .mp4 file under the <code>directory_to_process</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; directory_to_process = &quot;Visions2/Alfven_475s&quot;;

# Using defaults for angles and colorrange:
julia&gt; animate_Ie_in_time(directory_to_process)

# Or with custom angles and colorrange:
julia&gt; angles_to_plot = [(180, 170)  (170, 150)  (150, 120)  (120, 100)  (100, 90);   # DOWN
                         (0, 10)     (10, 30)    (30, 60)    (60, 80)    (80, 90)];   # UP
julia&gt; animate_Ie_in_time(directory_to_process; angles_to_plot, colorrange=(1e5, 1e9), plot_Ietop=true)

# Using nothing for empty panels:
julia&gt; angles_to_plot = [(180, 90)  nothing;
                         (0, 45)    (45, 90)];
julia&gt; animate_Ie_in_time(directory_to_process; angles_to_plot)</code></pre><p>The <code>angles_to_plot</code> is a matrix of tuples, where each tuple defines a pitch-angle range from 0° to 180° (where 180° is field-aligned down and 0° is field-aligned up). A panel will be created for each matrix element at the corresponding row/column position. Angles &gt; 90° are labeled as &quot;DOWN&quot;, angles &lt; 90° as &quot;UP&quot;. Use <code>nothing</code> for empty panels.</p><p>The limits of <code>angles_to_plot</code> need to match existing limits of the beams used in the simulation. E.g. if <code>θ_lims = 180:-10:0</code> was used in the simulation, <code>(150, 120)</code> will be fine as 150° and 120° exist as limits, but <code>(155, 120)</code> will not as 155° does not exist as a limit.</p><p><strong>Arguments</strong></p><ul><li><code>directory_to_process</code>: directory containing the simulation results (absolute or relative path).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>angles_to_plot = nothing</code>: limits of the angles to plot as a matrix of tuples with angles                             in range 0-180°. Use <code>nothing</code> for empty panels. If the whole                             argument is <code>nothing</code>, uses the θ_lims grid from the simulation                             with down-flux on the first row and up-flux on the second row.</li><li><code>colorrange = nothing</code>: limits for the colormap/colorbar as a tuple (min, max). If <code>nothing</code>,                         automatically computed as (max<em>value / 1e4, max</em>value) spanning                         4 orders of magnitude.</li><li><code>save_to_file = true</code>: if true, saves the animation to a .mp4 file in the data directory.</li><li><code>plot_Ietop = false</code>: if true, also plots the precipitating Ie at the top of the                       ionosphere by loading it from the file <code>Ie_top.mat</code>.</li><li><code>Ietop_angle_cone = [170, 180]</code>: angle cone (in degrees) for the precipitating Ie                       to plot.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/AURORA.jl#L47-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.beam_weight-Tuple{Any}"><a class="docstring-binding" href="#AURORA.beam_weight-Tuple{Any}"><code>AURORA.beam_weight</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">beam_weight(θ_lims)</code></pre><p>Return the beam weights of the pitch-angle beams delimited by θ_lims.</p><p><strong>Calling</strong></p><p><code>BeamW = beam_weight(θ_lims)</code></p><p><strong>Inputs</strong></p><ul><li><code>θ_lims</code> : pitch-angle limits of all the beams, range or vector [n_beams + 1]</li></ul><p><strong>Outputs</strong></p><ul><li><code>BeamW</code> : solid angle of each pitch-angle beams (ster), vector [n_beams]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/utilities.jl#L77-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_cascading_N2"><a class="docstring-binding" href="#AURORA.calculate_cascading_N2"><code>AURORA.calculate_cascading_N2</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calculate_cascading_N2(E_grid, dE, lorentzian_width)</code></pre><p>Calculate cascading transfer matrices for N₂ ionization.</p><p><strong>Arguments</strong></p><ul><li><code>E_grid</code>: Energy grid for electrons (eV)</li><li><code>dE</code>: Energy grid step size (eV)</li><li><code>lorentzian_width</code>: Width of the Lorentzian distribution (eV)</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_transfer_matrix</code>: Transfer matrix [n<em>energies, n</em>energies, n_thresholds]</li></ul><p><strong>Reference</strong></p><p>Equation from Itikawa 1986 J. Phys. Chem. Ref. Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/cascading.jl#L334-L349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_cascading_N2_quadgk"><a class="docstring-binding" href="#AURORA.calculate_cascading_N2_quadgk"><code>AURORA.calculate_cascading_N2_quadgk</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calculate_cascading_N2_quadgk(E_grid, dE, lorentzian_width)</code></pre><p>Calculate cascading transfer matrices for N₂ ionization using nested quadgk integrals.</p><p>This is an alternative implementation to <code>calculate_cascading_N2</code> that uses two nested one-dimensional integrals instead of a hypercube transformation. The integration is performed over the physical domain directly:</p><ul><li>Outer integral: over degraded electron energy E_degraded</li><li>Inner integral: over primary electron energy E_primary</li></ul><p><strong>Arguments</strong></p><ul><li><code>E_grid</code>: Energy grid for electrons (eV)</li><li><code>dE</code>: Energy grid step size (eV)</li><li><code>lorentzian_width</code>: Width of the Lorentzian distribution (eV)</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_transfer_matrix</code>: Transfer matrix [n<em>energies, n</em>energies, n_thresholds]</li><li><code>E_grid</code>: Energy grid (returned for consistency)</li><li><code>ionization_thresholds</code>: Array of ionization threshold energies</li></ul><p><strong>Reference</strong></p><p>Equation from Itikawa 1986 J. Phys. Chem. Ref. Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/cascading.jl#L429-L452">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_cascading_O-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.calculate_cascading_O-Tuple{Any, Any}"><code>AURORA.calculate_cascading_O</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_cascading_O(E_grid, dE)</code></pre><p>Calculate cascading transfer matrices for atomic O ionization.</p><p><strong>Arguments</strong></p><ul><li><code>E_grid</code>: Energy grid for electrons (eV)</li><li><code>dE</code>: Energy grid step size (eV)</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_transfer_matrix</code>: Transfer matrix [n<em>energies, n</em>energies, n_thresholds]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/cascading.jl#L732-L743">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_cascading_O2"><a class="docstring-binding" href="#AURORA.calculate_cascading_O2"><code>AURORA.calculate_cascading_O2</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calculate_cascading_O2(E_grid, dE, lorentzian_width)</code></pre><p>Calculate cascading transfer matrices for O₂ ionization.</p><p><strong>Arguments</strong></p><ul><li><code>E_grid</code>: Energy grid for electrons (eV)</li><li><code>dE</code>: Energy grid step size (eV)</li><li><code>lorentzian_width</code>: Width of the Lorentzian distribution (eV)</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_transfer_matrix</code>: Transfer matrix [n<em>energies, n</em>energies, n_thresholds]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/cascading.jl#L523-L535">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_cascading_O2_quadgk"><a class="docstring-binding" href="#AURORA.calculate_cascading_O2_quadgk"><code>AURORA.calculate_cascading_O2_quadgk</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calculate_cascading_O2_quadgk(E_grid, dE, lorentzian_width)</code></pre><p>Calculate cascading transfer matrices for O₂ ionization using nested quadgk integrals.</p><p>This is an alternative implementation to <code>calculate_cascading_O2</code> that uses two nested one-dimensional integrals instead of a hypercube transformation. The integration is performed over the physical domain directly:</p><ul><li>Outer integral: over degraded electron energy E_degraded</li><li>Inner integral: over primary electron energy E_primary</li></ul><p><strong>Arguments</strong></p><ul><li><code>E_grid</code>: Energy grid for electrons (eV)</li><li><code>dE</code>: Energy grid step size (eV)</li><li><code>lorentzian_width</code>: Width of the Lorentzian distribution (eV)</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_transfer_matrix</code>: Transfer matrix [n<em>energies, n</em>energies, n_thresholds]</li><li><code>E_grid</code>: Energy grid (returned for consistency)</li><li><code>ionization_thresholds</code>: Array of ionization threshold energies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/cascading.jl#L609-L629">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_cascading_O_quadgk-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.calculate_cascading_O_quadgk-Tuple{Any, Any}"><code>AURORA.calculate_cascading_O_quadgk</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_cascading_O_quadgk(E_grid, dE)</code></pre><p>Calculate cascading transfer matrices for atomic O ionization using nested quadgk integrals.</p><p>This is an alternative implementation to <code>calculate_cascading_O</code> that uses two nested one-dimensional integrals instead of a hypercube transformation. The integration is performed over the physical domain directly:</p><ul><li>Outer integral: over degraded electron energy E_degraded</li><li>Inner integral: over primary electron energy E_primary</li></ul><p><strong>Arguments</strong></p><ul><li><code>E_grid</code>: Energy grid for electrons (eV)</li><li><code>dE</code>: Energy grid step size (eV)</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_transfer_matrix</code>: Transfer matrix [n<em>energies, n</em>energies, n_thresholds]</li><li><code>E_grid</code>: Energy grid (returned for consistency)</li><li><code>ionization_thresholds</code>: Array of ionization threshold energies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/cascading.jl#L827-L846">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_density_from_Ie!-NTuple{7, Any}"><a class="docstring-binding" href="#AURORA.calculate_density_from_Ie!-NTuple{7, Any}"><code>AURORA.calculate_density_from_Ie!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_density_from_Ie!(h_atm, t_run, μ_lims, E_middle_bin, v, Ie, n_e)</code></pre><p>This function converts a particle flux <code>Ie</code> (#e⁻/m²/s) into a number density <code>n_e</code> (#e⁻/m³).</p><p>The particle flux <code>Ie</code> is defined along a magnetic field line and over an (Energy, pitch_angle)-grid. The number density <code>n_e</code> calculated is given along a magnetic field line and over an energy grid. That way, we have the density of electrons with a certain energy at a specific altitude and time.</p><p><strong>Calling</strong></p><p><code>calculate_density_from_Ie!(h_atm, t_run, μ_lims, E_middle_bin, v, Ie, n_e)</code></p><p><strong>Inputs</strong></p><ul><li><code>h_atm</code>: altitude (m), vector [nz]</li><li><code>t_run</code>: time (s), vector [nt]</li><li><code>μ_lims</code>: cosine of the pitch angle limits of the e- beams, vector [n_beam + 1]</li><li><code>E_middle_bin</code>: middle energy of the energy bins (eV), vector [nE]</li><li><code>v</code>: velocity corresponding to the <code>E_middle_bin</code> (m/s), vector [nE]</li><li><code>Ie</code>: electron flux (#e⁻/m²/s), 3D array [n_beam * nz, nt, nE]</li><li><code>n_e</code>: electron density (#e⁻/m³), <strong>empty</strong> 3D array [nz, nt, nE]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L89-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_heating_rate-NTuple{6, Any}"><a class="docstring-binding" href="#AURORA.calculate_heating_rate-NTuple{6, Any}"><code>AURORA.calculate_heating_rate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_heating_rate(h_atm, t, Ie_ztE_omni, E, ne, Te)</code></pre><p>Calculate the heating rate of thermal electrons by superthermal electrons through Coulomb collisions. The heating rate is the rate at which energy is transferred from superthermal electrons to thermal electrons.</p><p><strong>Calling</strong></p><p><code>heating_rate = calculate_heating_rate(h_atm, t, Ie_ztE_omni, E, ne, Te)</code></p><p><strong>Inputs</strong></p><ul><li><code>h_atm</code>: altitude (m). Vector [n_z]</li><li><code>t</code>: time (s). Vector [n_t]</li><li><code>Ie_ztE_omni</code>: omnidirectional electron flux (#e⁻/m²/s). 3D array [n_z, n_t, n_E]</li><li><code>E</code>: energy (eV). Vector [n_E]</li><li><code>ne</code>: thermal electron density (m⁻³). Vector [n_z]</li><li><code>Te</code>: thermal electron temperature (K). Vector [n_z]</li></ul><p><strong>Output</strong></p><ul><li><code>heating_rate</code>: heating rate (eV/m³/s). 2D array [n_z, n_t]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L957-L977">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_iri_data-Tuple{}"><a class="docstring-binding" href="#AURORA.calculate_iri_data-Tuple{}"><code>AURORA.calculate_iri_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_iri_data(; year=2018, month=12, day=7, hour=11, minute=15,
                    lat=76, lon=5, height=85:1:700)</code></pre><p>Calculate IRI-2016 ionospheric model data using Python interface.</p><p>This function calls the Python <code>iri2016</code> package to compute ionospheric parameters including electron density, temperatures, and ion composition profiles. The data is returned as a matrix with a header row containing column names.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>year::Int=2018</code>: Year (defaults to Visions2 launch conditions)</li><li><code>month::Int=12</code>: Month (1-12)</li><li><code>day::Int=7</code>: Day of month (1-31)</li><li><code>hour::Int=11</code>: Hour in Universal Time (0-23)</li><li><code>minute::Int=15</code>: Minute (0-59)</li><li><code>lat::Real=76</code>: Geographic latitude in degrees North</li><li><code>lon::Real=5</code>: Geographic longitude in degrees East</li><li><code>height::AbstractRange=85:1:700</code>: Altitude range in km</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Matrix, NamedTuple}</code>:<ul><li>Matrix with header row and IRI data (21 columns: height + 20 parameters)</li><li>NamedTuple with input parameters</li></ul></li></ul><p><strong>Data Columns</strong></p><p>The returned matrix contains the following columns:</p><ol><li>height(km): Altitude</li><li>ne(m⁻³): Electron density</li><li>Tn(K): Neutral temperature</li><li>Ti(K): Ion temperature</li><li>Te(K): Electron temperature</li></ol><p>6-12. nO⁺, nH⁺, nHe⁺, nO2⁺, nNO⁺, nCI, nN⁺: Ion densities (m⁻³) 13-18. NmF2, hmF2, NmF1, hmF1, NmE, hmE: Peak densities and heights</p><ol><li>TEC: Total Electron Content</li><li>EqVertIonDrift: Equatorial vertical ion drift</li><li>foF2: F2 critical frequency</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/iri/calculation.jl#L3-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_msis_data-Tuple{}"><a class="docstring-binding" href="#AURORA.calculate_msis_data-Tuple{}"><code>AURORA.calculate_msis_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_msis_data(; year=2018, month=12, day=7, hour=11, minute=15,
                     lat=76, lon=5, height=85:1:700)</code></pre><p>Calculate NRLMSIS 2.1 atmospheric model data using Python interface.</p><p>This function calls the Python <code>pymsis</code> package to compute neutral atmosphere parameters including densities of various species (N₂, O₂, O, He, H, Ar, N, NO) and temperature profiles. The data is returned as a matrix with a header row containing column names.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>year::Int=2018</code>: Year (defaults to Visions2 launch conditions)</li><li><code>month::Int=12</code>: Month (1-12)</li><li><code>day::Int=7</code>: Day of month (1-31)</li><li><code>hour::Int=11</code>: Hour in Universal Time (0-23)</li><li><code>minute::Int=15</code>: Minute (0-59)</li><li><code>lat::Real=76</code>: Geographic latitude in degrees North</li><li><code>lon::Real=5</code>: Geographic longitude in degrees East</li><li><code>height::AbstractRange=85:1:700</code>: Altitude range in km</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Matrix, NamedTuple}</code>:<ul><li>Matrix with header row and MSIS data (12 columns: height + 11 parameters)</li><li>NamedTuple with input parameters</li></ul></li></ul><p><strong>Data Columns</strong></p><p>The returned matrix contains the following columns:</p><ol><li>height(km): Altitude</li><li>air(kg/m³): Total mass density</li><li>N₂(m⁻³): Molecular nitrogen density</li><li>O₂(m⁻³): Molecular oxygen density</li><li>O(m⁻³): Atomic oxygen density</li><li>He(m⁻³): Helium density</li><li>H(m⁻³): Atomic hydrogen density</li><li>Ar(m⁻³): Argon density</li><li>N(m⁻³): Atomic nitrogen density</li><li>anomalousO(m⁻³): Anomalous oxygen density</li><li>NO(m⁻³): Nitric oxide density</li><li>T(K): Temperature</li></ol><p><strong>Notes</strong></p><ul><li>This function automatically downloads the SW-All.csv file (space weather data) if not already present in the pymsis package directory</li><li>The geomagnetic activity parameter is set to -1 (use observational data)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/msis/calculation.jl#L5-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_n_loop-NTuple{4, Any}"><a class="docstring-binding" href="#AURORA.calculate_n_loop-NTuple{4, Any}"><code>AURORA.calculate_n_loop</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_n_loop(t, n_z, n_μ, n_E; max_memory_gb=8, verbose=true)</code></pre><p>Calculate the optimal number of loops (<code>n_loop</code>) for the electron transport simulation based on memory constraints.</p><p>This function determines how many time-slices the simulation should be divided into to stay within the specified memory limit.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: Time array after CFL refinement (from <code>CFL_criteria</code>)</li><li><code>n_z::Int</code>: Number of altitude grid points</li><li><code>n_μ::Int</code>: Number of pitch-angle beams</li><li><code>n_E::Int</code>: Number of energy grid points</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>max_memory_gb</code>: Maximum memory to use (GB). Defaults to 8 GB.</li><li><code>verbose::Bool=true</code>: If true, print some information about the calculation</li></ul><p><strong>Returns</strong></p><ul><li><code>n_loop::Int</code>: Recommended number of loops</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">t, CFL_factor = CFL_criteria(1.0, 0.001, h_atm, v_of_E(10000))
n_loop = calculate_n_loop(t, length(h_atm), n_μ, n_E)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/utilities.jl#L496-L523">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_scattered_flux!-NTuple{4, Any}"><a class="docstring-binding" href="#AURORA.calculate_scattered_flux!-NTuple{4, Any}"><code>AURORA.calculate_scattered_flux!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_scattered_flux!(result, B2B_inelastic, n, Ie_slice)</code></pre><p>Calculate the flux of electrons after pitch-angle scattering by inelastic collisions.</p><p><strong>Physics</strong></p><p>The scattered flux at each altitude and angle is computed as:     result[z, μ₁, t] = Σ_μ₂ n(z) x P(μ₁←μ₂) x Ie[z, μ₂, t]</p><p>where:</p><ul><li><code>n(z)</code> is the neutral density at altitude z</li><li><code>P(μ₁←μ₂)</code> is the probability of scattering from pitch angle μ₂ to μ₁ (from B2B_inelastic)</li><li><code>Ie[z, μ₂, t]</code> is the incident electron flux before scattering</li></ul><p><strong>Implementation</strong></p><p>This exploits the block-diagonal structure of the full scattering matrix to avoid storing and accessing a large sparse matrix. Instead, it computes the multiplication directly from the small scattering probability matrix and density profile.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: Output array (n<em>z x n</em>μ, n_t) - scattered electron flux</li><li><code>B2B_inelastic</code>: Scattering probability matrix (n<em>μ, n</em>μ) - pitch angle redistribution</li><li><code>n</code>: Neutral density profile (n_z,) - altitude-dependent density [m⁻³]</li><li><code>Ie_slice</code>: Incident electron flux at the current energy (n<em>z x n</em>μ, n_t) - flux before scattering</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/energy_degradation.jl#L93-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_scattering_matrices"><a class="docstring-binding" href="#AURORA.calculate_scattering_matrices"><code>AURORA.calculate_scattering_matrices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calculate_scattering_matrices(θ_lims, n_direction = 720)</code></pre><p>Calculate the scattering matrices for given pitch-angle limits <code>θ_lims</code> of the electron beams. Uses 720 directions by default for the start angle and the scattering angles, equivalent to (1/4)° steps.</p><p><strong>Calling</strong></p><p><code>Pmu2mup, theta2beamW, BeamWeight_relative, θ₁ =  calculate_scattering_matrices(θ_lims, n_direction)</code></p><p><strong>Inputs</strong></p><ul><li><code>θ_lims</code>: pitch-angle limits of the electron beams (e.g. 180:-10:0), where 180°   corresponds to field aligned down, and 0° field aligned up.</li><li><code>n_direction</code>: number of directions or sub-beams to use for the discretized calculations   of the scattering matrices. Defaults to 720 when left empty.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Pmu2mup</code>: probabilities for scattering in 3D from beam to beam. Matrix [n_direction x * n_direction x n_beam]</li><li><code>theta2beamW</code>: weight of each sub-beam within each beam. Matrix [n_beam x n_direction]</li><li><code>BeamWeight_relative</code>: relative weight of each sub-beam within each beam. It is the same   as theta2beamW but normalized so that summing along the sub-beams gives 1 for each beam.   Matrix [n_beam x n_direction]</li><li><code>θ₁</code>: scattering angles used in the calculations. Vector [n_direction]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/scattering.jl#L90-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_scattering_matrices_legacy"><a class="docstring-binding" href="#AURORA.calculate_scattering_matrices_legacy"><code>AURORA.calculate_scattering_matrices_legacy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calculate_scattering_matrices_legacy(θ_lims, n_direction=720)</code></pre><p>Calculate the scattering matrices for given pitch-angle limits <code>θ_lims</code> of the electron beams.</p><p><strong>Calling</strong></p><p><code>Pmu2mup, theta2beamW, BeamWeight_relative, θ₁ =  calculate_scattering_matrices_legacy(θ_lims, n_direction)</code></p><p><strong>Inputs</strong></p><ul><li><code>θ_lims</code>: pitch-angle limits of the electron beams (e.g. 180:-10:0), where 180°   corresponds to field aligned down, and 0° field aligned up.</li><li><code>n_direction</code>: number of directions or sub-beams to use for the discretized calculations   of the scattering matrices. Defaults to 720 when left empty.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Pmu2mup</code>: probabilities for scattering in 3D from beam to beam. Matrix [n_direction x   2 * n_direction x n_beam]</li><li><code>theta2beamW</code>: weight of each sub-beam within each beam. Matrix [n_beam x   n_direction]</li><li><code>BeamWeight_relative</code>: relative weight of each sub-beam within each beam. It is the same   as theta2beamW but normalized so that summing along the sub-beams gives 1 for each beam.   Matrix [n_beam x n_direction]</li><li><code>θ₁</code>: scattering angles used in the calculations. Vector [n_direction]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/scattering.jl#L190-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.calculate_volume_excitation-NTuple{5, Any}"><a class="docstring-binding" href="#AURORA.calculate_volume_excitation-NTuple{5, Any}"><code>AURORA.calculate_volume_excitation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_volume_excitation(h_atm, t, Ie_ztE_omni, σ, n)</code></pre><p>Calculate the volume-excitation-rate for an excitation of interest, produced by the electron flux <code>Ie_ztE_omni</code> that is summed over the beams (omnidirectional).</p><p>The excitation of interest is chosen through the cross-section <code>σ</code> given to the function. Note that the neutral density <code>n</code> should match the excitation of interest (e.g. use nN2 when calculating the volume-excitation-rate of the 4278Å optical emission).</p><p><strong>Calling</strong></p><p><code>Q = calculate_volume_excitation(h_atm, t, Ie_ztE, σ, n)</code>`</p><p><strong>Inputs</strong></p><ul><li><code>h_atm</code>: altitude (m). Vector [n_z]</li><li><code>t</code>: time (s). Vector [n_t]</li><li><code>Ie_ztE_omni</code>: omnidirectional electron flux (#e⁻/m²/s). 3D array [n_z, n_t, n_E]</li><li><code>σ</code>: excitation cross-section (m⁻²). Vector [n_E]</li><li><code>n</code>: density of exciteable atmospheric specie (m⁻³). Vector [n_z]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L331-L350">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.create_crank_nicolson_nzval_mappings-NTuple{4, Any}"><a class="docstring-binding" href="#AURORA.create_crank_nicolson_nzval_mappings-NTuple{4, Any}"><code>AURORA.create_crank_nicolson_nzval_mappings</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_crank_nicolson_nzval_mappings(Mlhs, Mrhs, n_z, n_angle)</code></pre><p>Create mappings for both Mlhs and Mrhs matrices. Returns (mapping<em>lhs, mapping</em>rhs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/crank_nicolson_optimized.jl#L143-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.create_crank_nicolson_sparsity_patterns-NTuple{5, Any}"><a class="docstring-binding" href="#AURORA.create_crank_nicolson_sparsity_patterns-NTuple{5, Any}"><code>AURORA.create_crank_nicolson_sparsity_patterns</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_crank_nicolson_sparsity_patterns(n_z, n_angle, μ, D, Ddiffusion)</code></pre><p>Create the sparsity patterns for both Mlhs and Mrhs matrices. The structure is the same for both, only values differ.</p><p>Returns (Mlhs, Mrhs) with correct sparsity structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/crank_nicolson_optimized.jl#L10-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.create_steady_state_nzval_mapping-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#AURORA.create_steady_state_nzval_mapping-Tuple{Any, Any, Any}"><code>AURORA.create_steady_state_nzval_mapping</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_steady_state_nzval_mapping(Mlhs, n_z, n_angle)</code></pre><p>Create a mapping from matrix block positions to nzval indices for efficient in-place updates.</p><p>Julia uses the CSC (Compressed Sparse Column) format for sparse matrices, with three arrays:</p><ul><li>colptr: Column pointers (which rows are in each column)</li><li>rowval: Row indices of non-zero values</li><li>nzval: The actual non-zero values</li></ul><p>This function computes a mapping that tells us which index in <code>nzval</code> corresponds to each matrix element we want to update. With this mapping, we can directly modify <code>nzval</code> in place, avoiding expensive matrix reconstruction.</p><p>Returns a structured mapping where <code>mapping[i1, i2][(:type, position)]</code> gives the nzval index for the specified matrix element in block (i1, i2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/steady_state_optimized.jl#L109-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.create_steady_state_sparsity_pattern-NTuple{5, Any}"><a class="docstring-binding" href="#AURORA.create_steady_state_sparsity_pattern-NTuple{5, Any}"><code>AURORA.create_steady_state_sparsity_pattern</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_steady_state_sparsity_pattern(n_z, n_angle, μ, D, Ddiffusion)</code></pre><p>Create the sparsity pattern (structure) of the steady-state LHS matrix once. This can be reused by only modifying nzval values, avoiding allocations.</p><p>Returns the sparse matrix with the correct structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/steady_state_optimized.jl#L8-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.downsampling_fluxes-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.downsampling_fluxes-Tuple{Any, Any}"><code>AURORA.downsampling_fluxes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">downsampling_fluxes(directory_to_process, downsampling_factor)</code></pre><p>This function extracts <code>Ie</code> from the simulation results in <code>directory_to_process</code> and downsample it in time. For example: if <code>Ie</code> is given with a time step of 1ms and we use a <code>downsampling_factor</code> of 10, this function will extract the values of <code>Ie</code> with a time step of 10ms. It will then save the results in a new subfolder called<code>downsampled_10x</code>, inside the <code>directory_to_process</code>.</p><p><strong>Calling</strong></p><p><code>downsampling_fluxes(directory_to_process, downsampling_factor)</code></p><p><strong>Inputs</strong></p><ul><li><code>directory_to_process</code>: absolute or relative path to the simulation directory to process.</li><li><code>downsampling_factor</code>: downsampling factor for the time</li></ul><p><strong>Outputs</strong></p><p>The downsampled electron fluxes <code>Ie</code> will be saved in a subfolder inside the <code>directory_to_process</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L779-L797">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.excitation_4278-Tuple{Any}"><a class="docstring-binding" href="#AURORA.excitation_4278-Tuple{Any}"><code>AURORA.excitation_4278</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">excitation_4278(E)</code></pre><p>Returns the electron-impact excitation cross-section for 4278Å from N2 ions.</p><p>Best fit to experiments (Tima Sergienko, personal communication).</p><p><strong>Calling</strong></p><p>σ = excitation_4278(E)</p><p><strong>Input</strong></p><ul><li><code>E</code>: incoming electron energy (eV)</li></ul><p><strong>Output</strong></p><ul><li><code>σ</code>: emission cross-section (m²)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/internal_data/data_electron/emission_cross_sections.jl#L4-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.excitation_6730_N2-Tuple{Any}"><a class="docstring-binding" href="#AURORA.excitation_6730_N2-Tuple{Any}"><code>AURORA.excitation_6730_N2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">excitation_6730_N2(E)</code></pre><p>Returns the electron-impact excitation cross-section for 6730Å bands from N2 for transitions 4-1 and 5-2.</p><p>Digitised and extrapolated from Lanchester et al. (2009), p. 2545. https://doi.org/10.5194/angeo-27-2881-2009</p><p>% parent       N2 % products     0    (emission) % threshold    7.3532   (???) % units        eV</p><p><strong>Calling</strong></p><p>σ = excitation_6730_N2(E)</p><p><strong>Input</strong></p><ul><li><code>E</code>: incoming electron energy (eV)</li></ul><p><strong>Output</strong></p><ul><li><code>σ</code>: emission cross-section (m²)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/internal_data/data_electron/emission_cross_sections.jl#L45-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.excitation_7774_O-Tuple{Any}"><a class="docstring-binding" href="#AURORA.excitation_7774_O-Tuple{Any}"><code>AURORA.excitation_7774_O</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">excitation_7774_O(E)</code></pre><p>Returns the electron-impact excitation cross-section for 7774Å from O. Produced by the transition     groud-state –(different pathways)–&gt; OI 3p 5P –(prompt emission of 7774Å)–&gt; OI 3s 5S</p><p>Digitized and extrapolated from Julienne and Davis (1976), p. 1397. https://doi.org/10.1029/JA081i007p01397</p><p>% 	typed in by Mina Ashrafi July 2008 % parent       O % products     0    (emission) % threshold    10.74   (Itikawa Corrected:BG-20191016) % units        eV</p><p><strong>Calling</strong></p><p>σ = excitation_7774_O(E)</p><p><strong>Input</strong></p><ul><li><code>E</code>: incoming electron energy (eV)</li></ul><p><strong>Output</strong></p><ul><li><code>σ</code>: emission cross-section (m²)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/internal_data/data_electron/emission_cross_sections.jl#L296-L320">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.excitation_7774_O2-Tuple{Any}"><a class="docstring-binding" href="#AURORA.excitation_7774_O2-Tuple{Any}"><code>AURORA.excitation_7774_O2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">excitation_7774_O2(E)</code></pre><p>Returns the electron-impact excitation cross-section for 7774Å from O2. Produced by the dissociative ionization/excitation of     O2 –(different pathways)–&gt; OI 3p 5P –(prompt emission of 7774Å)–&gt; OI 3s 5S</p><p>From Erdman and Zipf (1987), p. 4540. https://doi.org/10.1063/1.453696</p><p>% 	typed in by Mykola/Nickolay Ivshenko August 2006 % parent       O2 % products     0    (emission) % threshold    15.9   (???) Seems OK, 10.74 + 5.15 (O2-bond-energy) % units        eV</p><p><strong>Calling</strong></p><p>σ = excitation_7774_O2(E)</p><p><strong>Input</strong></p><ul><li><code>E</code>: incoming electron energy (eV)</li></ul><p><strong>Output</strong></p><ul><li><code>σ</code>: emission cross-section (m²)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/internal_data/data_electron/emission_cross_sections.jl#L411-L435">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.excitation_8446_O-Tuple{Any}"><a class="docstring-binding" href="#AURORA.excitation_8446_O-Tuple{Any}"><code>AURORA.excitation_8446_O</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">excitation_8446_O(E)</code></pre><p>Returns the electron-impact excitation cross-section for 8446Å from O. Produced by the transition     ground-state –(different pathways)–&gt; OI 3p 3P –(prompt emission of 8446Å)–&gt; ??</p><p>From Itikawa and Ichimura (1990). https://doi.org/10.1063/1.555857</p><p>% parent       O % products     0    (emission) % threshold    10.99   (Itikawa) Confirmed/BG-20191016 % units        eV</p><p><strong>Calling</strong></p><p>σ = excitation_8446_O(E)</p><p><strong>Input</strong></p><ul><li><code>E</code>: incoming electron energy (eV)</li></ul><p><strong>Output</strong></p><ul><li><code>σ</code>: emission cross-section (m²)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/internal_data/data_electron/emission_cross_sections.jl#L117-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.excitation_8446_O2-Tuple{Any}"><a class="docstring-binding" href="#AURORA.excitation_8446_O2-Tuple{Any}"><code>AURORA.excitation_8446_O2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">excitation_8446_O2(E)</code></pre><p>Returns the electron-impact excitation cross-section for 8446Å from O2. Produced by the dissociative ionization/excitation of     O2 –(different pathways)–&gt; OI 3p 3P –(prompt emission of 8446Å)–&gt; ??</p><p>From Schulman et al. (1985). Digitised from fig.7 by Daniel Whiter in March 2009. Value in paper is 2 +/- 15% @ 100eV. https://doi.org/10.1103/PhysRevA.32.2100</p><p>% parent       O2 % products     0    (emission) % threshold    15.9   (???) - seems low, dissociation energy of O2 %                             is 5.16 eV and the energy-level of %                             O(3p3P) is 10.99 eV, so threshold has %                             to  be 16.15 eV /BG 20180529</p><p><strong>Calling</strong></p><p>σ = excitation_8446_O2(E)</p><p><strong>Input</strong></p><ul><li><code>E</code>: incoming electron energy (eV)</li></ul><p><strong>Output</strong></p><ul><li><code>σ</code>: emission cross-section (m²)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/internal_data/data_electron/emission_cross_sections.jl#L200-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.excitation_O1D-Tuple{Any}"><a class="docstring-binding" href="#AURORA.excitation_O1D-Tuple{Any}"><code>AURORA.excitation_O1D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">excitation_O1D(E)</code></pre><p>Returns the electron-impact excitation cross-section for O1D (will emit 6300Å, not prompt).</p><p>From Itikawa and Ichimura (1990). https://doi.org/10.1063/1.555857</p><p><strong>Calling</strong></p><p>σ = excitation_O1D(E)</p><p><strong>Input</strong></p><ul><li><code>E</code>: incoming electron energy (eV)</li></ul><p><strong>Output</strong></p><ul><li><code>σ</code>: emission cross-section (m²)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/internal_data/data_electron/emission_cross_sections.jl#L517-L533">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.excitation_O1S-Tuple{Any}"><a class="docstring-binding" href="#AURORA.excitation_O1S-Tuple{Any}"><code>AURORA.excitation_O1S</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">excitation_O1S(E)</code></pre><p>Returns the electron-impact excitation cross-section for O1S (will emit 5577Å, not prompt).</p><p>From Itikawa and Ichimura (1990). https://doi.org/10.1063/1.555857</p><p><strong>Calling</strong></p><p>σ = excitation_O1S(E)</p><p><strong>Input</strong></p><ul><li><code>E</code>: incoming electron energy (eV)</li></ul><p><strong>Output</strong></p><ul><li><code>σ</code>: emission cross-section (m²)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/internal_data/data_electron/emission_cross_sections.jl#L560-L576">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.find_Ietop_file-Tuple{Any}"><a class="docstring-binding" href="#AURORA.find_Ietop_file-Tuple{Any}"><code>AURORA.find_Ietop_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_Ietop_file(path_to_directory)</code></pre><p>Look for Ie_incoming file present in the directory given by <code>path_to_directory</code>. If several files are starting with the name &quot;Ie_incoming&quot;, return an error. If only one file is found, return a string with the path to that file.</p><p><strong>Calling</strong></p><p><code>Ietop_file = find_Ietop_file(path_to_directory)</code></p><p><strong>Inputs</strong></p><ul><li><code>path_to_directory</code>: path to a directory</li></ul><p><strong>Returns</strong></p><ul><li><code>Ietop_file</code>: path to the Ie_incoming file, in the form &quot;path<em>to</em>directory/Ie<em>incoming</em>*.mat&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/utilities.jl#L212-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.find_cascading_file-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.find_cascading_file-Tuple{Any, Any}"><code>AURORA.find_cascading_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_cascading_file(E_grid, species_dir)</code></pre><p>Search for a pre-computed cascading spectra file with matching energy grid.</p><p><strong>Arguments</strong></p><ul><li><code>E_grid</code>: Energy grid to match</li><li><code>species_dir</code>: Directory containing cascading data files for the species</li></ul><p><strong>Returns</strong></p><ul><li><code>(file_found, filepath)</code>: Tuple of boolean and filepath string</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/cascading.jl#L14-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.find_iri_file-Tuple{}"><a class="docstring-binding" href="#AURORA.find_iri_file-Tuple{}"><code>AURORA.find_iri_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_iri_file(; year=2018, month=12, day=7, hour=11, minute=15,
                lat=76, lon=5, height=85:1:700)</code></pre><p>Find or create an IRI model data file for the specified conditions.</p><p>It first searches for an existing IRI file matching the given parameters. If no matching file is found, it calculates new IRI data using the Python iri2016 package and saves it to a file. The iri2016 package will compile and run some fortran code under the hood.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>year::Int=2018</code>: Year</li><li><code>month::Int=12</code>: Month (1-12)</li><li><code>day::Int=7</code>: Day of month (1-31)</li><li><code>hour::Int=11</code>: Hour in Universal Time (0-23)</li><li><code>minute::Int=15</code>: Minute (0-59)</li><li><code>lat::Real=76</code>: Geographic latitude in degrees North</li><li><code>lon::Real=5</code>: Geographic longitude in degrees East</li><li><code>height::AbstractRange=85:1:700</code>: Altitude range in km</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Full path to the IRI data file</li></ul><p><strong>Notes</strong></p><ul><li>Default parameters correspond to the VISIONS-2 rocket launch conditions</li><li>Files are stored in <code>internal_data/data_electron/</code> directory</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/iri/iri.jl#L5-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.find_msis_file-Tuple{}"><a class="docstring-binding" href="#AURORA.find_msis_file-Tuple{}"><code>AURORA.find_msis_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_msis_file(; year=2018, month=12, day=7, hour=11, minute=15,
                lat=76, lon=5, height=85:1:700)</code></pre><p>Find or create a MSIS model data file for the specified conditions.</p><p>It first searches for an existing MSIS file matching the given parameters. If no matching file is found, it calculates new MSIS data using the Python pymsis package and saves it to a file. The pymsis package will download, compile and run some fortran code under the hood.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>year::Int=2018</code>: Year</li><li><code>month::Int=12</code>: Month (1-12)</li><li><code>day::Int=7</code>: Day of month (1-31)</li><li><code>hour::Int=11</code>: Hour in Universal Time (0-23)</li><li><code>minute::Int=15</code>: Minute (0-59)</li><li><code>lat::Real=76</code>: Geographic latitude in degrees North</li><li><code>lon::Real=5</code>: Geographic longitude in degrees East</li><li><code>height::AbstractRange=85:1:700</code>: Altitude range in km</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Full path to the MSIS data file</li></ul><p><strong>Notes</strong></p><ul><li>Default parameters correspond to the VISIONS-2 rocket launch conditions</li><li>Files are stored in <code>internal_data/data_neutrals/</code> directory</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/msis/msis.jl#L5-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.find_scattering_matrices"><a class="docstring-binding" href="#AURORA.find_scattering_matrices"><code>AURORA.find_scattering_matrices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_scattering_matrices(θ_lims, n_direction=720)</code></pre><p>Look for scattering matrices that match the pitch-angle limits <code>θ_lims</code> and the number of direction/sub-beams <code>n_direction</code>. If a file is found, the scattering matrices are directly loaded. Otherwise, they are calculated and saved to a file.</p><p><strong>Calling</strong></p><p><code>Pmu2mup, theta2beamW, BeamWeight_relative, θ₁ =  find_scattering_matrices(θ_lims, n_direction)</code></p><p><strong>Inputs</strong></p><ul><li><code>θ_lims</code>: pitch-angle limits of the electron beams (e.g. 180:-10:0), where 180°   corresponds to field aligned down, and 0° field aligned up.</li><li><code>n_direction</code>: number of directions or sub-beams to use for the discretized calculations   of the scattering matrices. Defaults to 720 when left empty.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Pmu2mup</code>: probabilities for scattering in 3D from beam to beam. Matrix [n<code>_</code>direction x   n<code>_</code>direction]</li><li><code>theta2beamW</code>: weight of each sub-beam within each beam. Matrix [n<code>_</code>beam x   n<code>_</code>direction]</li><li><code>BeamWeight_relative</code>: relative weight of each sub-beam within each beam. It is the same   as theta2beamW but normalized so that summing along the sub-beams gives 1 for each beam.   Matrix [n<code>_</code>beam x n<code>_</code>direction]</li><li><code>θ₁</code>: scattering angles used in the calculations. Vector [n_direction]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/scattering.jl#L6-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.get_cross_section-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#AURORA.get_cross_section-Tuple{Any, Any, Any}"><code>AURORA.get_cross_section</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_cross_section(species_name, E, dE)</code></pre><p>Calculate the cross-section for a given species and their different energy states.</p><p><strong>Calling</strong></p><p><code>σ_N2 = get_cross_section(&quot;N2&quot;, E, dE)</code></p><p><strong>Inputs</strong></p><ul><li><code>species_name</code>: name of the species. String</li><li><code>E</code>: energy grid (eV). Vector [nE]</li><li><code>dE</code>: energy grid step size (eV). Vector [nE]</li></ul><p><strong>Outputs</strong></p><ul><li><code>σ_species</code>: A matrix of cross-section values for each energy state, for the defined species</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/setup.jl#L329-L345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.initialize_transport_matrices-NTuple{6, Any}"><a class="docstring-binding" href="#AURORA.initialize_transport_matrices-NTuple{6, Any}"><code>AURORA.initialize_transport_matrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_transport_matrices(h_atm, μ_center, t, E, dE, θ_lims)</code></pre><p>Create a TransportMatrices container initialized with zeros for A, B, D, Q and Ddiffusion.</p><p><strong>Arguments</strong></p><ul><li><code>h_atm</code>: Altitude grid</li><li><code>μ_center</code>: Cosine of angle centers</li><li><code>t</code>: Time grid</li><li><code>E, dE</code>: Energy grid and bin widths</li><li><code>θ_lims</code>: Angle bin limits</li></ul><p><strong>Returns</strong></p><ul><li><code>matrices::TransportMatrices</code>: Initialized container for the transport matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/matrix_building.jl#L285-L299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.interpolate_O_parameters-Tuple{Any}"><a class="docstring-binding" href="#AURORA.interpolate_O_parameters-Tuple{Any}"><code>AURORA.interpolate_O_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_O_parameters(E_primary)</code></pre><p>Interpolate energy-dependent parameters for atomic O ionization.</p><p><strong>Arguments</strong></p><ul><li><code>E_primary</code>: Primary electron energy (eV)</li></ul><p><strong>Returns</strong></p><ul><li><code>(A_factor, B_factor)</code>: Tuple of interpolated parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/cascading.jl#L701-L711">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.interpolate_iri_to_grid-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.interpolate_iri_to_grid-Tuple{Any, Any}"><code>AURORA.interpolate_iri_to_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_iri_to_grid(iri_data, h_atm)</code></pre><p>Interpolate IRI data to a custom altitude grid.</p><p>This function interpolates all altitude-dependent densities and temperatures from IRI to a new altitude grid, while preserving scalar parameters (peak densities/heights, TEC, etc.).</p><p><strong>Arguments</strong></p><ul><li><code>iri_data</code>: NamedTuple from <code>load_iri_data()</code> or <code>load_iri().data</code></li><li><code>h_atm</code>: Target altitude grid (m). Vector [nZ]</li></ul><p><strong>Returns</strong></p><p>A NamedTuple with the same fields as <code>iri_data</code>, but with interpolated profiles:</p><ul><li><code>height_km</code>: converted target altitude grid (km). Vector [nZ]</li><li><code>ne</code>: interpolated electron density (m⁻³). Vector [nZ]</li><li><code>Tn</code>: interpolated neutral temperature (K). Vector [nZ]</li><li><code>Ti</code>: interpolated ion temperature (K). Vector [nZ]</li><li><code>Te</code>: interpolated electron temperature (K). Vector [nZ]</li><li><code>nO⁺</code>, <code>nH⁺</code>, <code>nHe⁺</code>, etc.: interpolated ion densities (m⁻³). Vector [nZ]</li><li><code>NmF2</code>, <code>hmF2</code>, <code>NmF1</code>, etc.: preserved scalar parameters (unchanged from input)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/iri/interpolation.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.interpolate_msis_to_grid-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.interpolate_msis_to_grid-Tuple{Any, Any}"><code>AURORA.interpolate_msis_to_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_msis_to_grid(msis_data, h_atm)</code></pre><p>Interpolate MSIS data to a custom altitude grid.</p><p>This function interpolates all altitude-dependent densities and temperature from MSIS to a new altitude grid. The interpolation is performed in log space for densities (which provides exponential extrapolation) and linear space for temperature.</p><p><strong>Arguments</strong></p><ul><li><code>msis_data</code>: NamedTuple from <code>load_msis_data()</code> or <code>load_msis().data</code></li><li><code>h_atm</code>: Target altitude grid (m). Vector [nZ]</li></ul><p><strong>Returns</strong></p><p>A NamedTuple with the following fields (all vectors of length nZ):</p><ul><li><code>height_km</code>: converted target altitude grid (km)</li><li><code>N2</code>: interpolated N₂ density (m⁻³)</li><li><code>O2</code>: interpolated O₂ density (m⁻³)</li><li><code>O</code>: interpolated O density (m⁻³)</li><li><code>T</code>: interpolated temperature (K)</li></ul><p><strong>Notes</strong></p><ul><li>Densities are interpolated in log space for better exponential behavior</li><li>Temperature is interpolated in linear space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/msis/interpolation.jl#L1-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.interpolate_profile-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#AURORA.interpolate_profile-Tuple{Any, Any, Any}"><code>AURORA.interpolate_profile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate_profile(data_values, data_altitude_km, target_altitude_m;
                   log_interpolation=true)</code></pre><p>Interpolate a single profile from one altitude grid to another.</p><p>This is a helper function for interpolating individual data profiles. Interpolation can be performed in linear or logarithmic space.</p><p><strong>Arguments</strong></p><ul><li><code>data_values::Vector</code>: The data to interpolate (e.g., density or temperature)</li><li><code>data_altitude_km::Vector</code>: Altitude grid of the input data (km)</li><li><code>target_altitude_m::Vector</code>: Target altitude grid for interpolation (m)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>log_interpolation::Bool=true</code>: If <code>true</code>, interpolation is done in log space (exponential   extrapolation). Recommended for densities. Use <code>false</code> for temperatures.</li></ul><p><strong>Returns</strong></p><ul><li><code>interpolated::Vector</code>: Interpolated data on the target altitude grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/utilities.jl#L442-L462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_cascading_matrices-Tuple{Any}"><a class="docstring-binding" href="#AURORA.load_cascading_matrices-Tuple{Any}"><code>AURORA.load_cascading_matrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_cascading_matrices(filepath)</code></pre><p>Load pre-computed cascading matrices from a file.</p><p><strong>Arguments</strong></p><ul><li><code>filepath</code>: Path to the .mat file containing cascading data</li></ul><p><strong>Returns</strong></p><ul><li><code>(Q_transfer_matrix, E_grid_for_Q, ionization_thresholds)</code>: Tuple of loaded data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/cascading.jl#L51-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_cross_sections-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.load_cross_sections-Tuple{Any, Any}"><code>AURORA.load_cross_sections</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_cross_sections(E, dE)</code></pre><p>Load the cross-sections of the neutrals species for their different energy states.</p><p><strong>Calling</strong></p><p><code>σ_neutrals = load_cross_sections(E, dE)</code></p><p><strong>Inputs</strong></p><ul><li><code>E</code>: energy grid (eV). Vector [nE]</li><li><code>dE</code>: energy grid step size (eV). Vector [nE]</li></ul><p><strong>Returns</strong></p><ul><li><code>σ_neutrals</code>: A named tuple containing the cross-sections (m⁻²) for N2, O2, and O.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/setup.jl#L303-L317">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_electron_densities-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.load_electron_densities-Tuple{Any, Any}"><code>AURORA.load_electron_densities</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_electron_densities(iri_file, h_atm)</code></pre><p>Load the electron density and temperature from an IRI file that was generated and saved using AURORA&#39;s IRI interface. Then interpolate the profiles over AURORA&#39;s altitude grid.</p><p><strong>Calling</strong></p><p><code>ne, Te = load_electron_densities(iri_file, h_atm)</code></p><p><strong>Inputs</strong></p><ul><li><code>iri_file</code>: absolute path to the iri file to read ne and Te from. String</li><li><code>h_atm</code>: altitude (m). Vector [nZ]</li></ul><p><strong>Returns</strong></p><ul><li><code>ne</code>: e- density (m⁻³). Vector [nZ]</li><li><code>Te</code>: e- temperature (K). Vector [nZ]</li></ul><p><strong>See also</strong></p><p><a href="#AURORA.load_iri-Tuple{Any}"><code>load_iri</code></a>, <a href="#AURORA.interpolate_iri_to_grid-Tuple{Any, Any}"><code>interpolate_iri_to_grid</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/setup.jl#L242-L261">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_excitation_threshold-Tuple{}"><a class="docstring-binding" href="#AURORA.load_excitation_threshold-Tuple{}"><code>AURORA.load_excitation_threshold</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_excitation_threshold()</code></pre><p>Load the excitation thresholds or energy levels of the different states (vibrational, rotational, ionization, ...) of the neutrals species as specified in the XX<em>levels.dat files. The corresponding names of the states can be found in the XX</em>levels.name files. XX refers to N2, O2 or O.</p><p><strong>Calling</strong></p><p><code>E_levels_neutrals = load_excitation_threshold()</code></p><p><strong>Returns</strong></p><ul><li><code>E_levels_neutrals</code>: A named tuple of matrices, namely <code>(N2_levels, O2_levels, O_levels)</code>.   The matrices have shape [n<code>_</code>levels x 2]. The first column contains the energy levels   and the second column contains the number of secondaries associated to that level (is   non-zero only for ionized states).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/setup.jl#L271-L287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_iri-Tuple{Any}"><a class="docstring-binding" href="#AURORA.load_iri-Tuple{Any}"><code>AURORA.load_iri</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_iri(iri_file)</code></pre><p>Load an IRI file and return both parameters and data.</p><p><strong>Arguments</strong></p><ul><li><code>iri_file</code>: Path to the IRI file to load</li></ul><p><strong>Returns</strong></p><p>A NamedTuple with two fields:</p><ul><li><code>parameters</code>: NamedTuple with (year, month, day, hour, minute, lat, lon, height)</li><li><code>data</code>: NamedTuple with all the IRI data columns</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/iri/io.jl#L67-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_iri_data-Tuple{Any}"><a class="docstring-binding" href="#AURORA.load_iri_data-Tuple{Any}"><code>AURORA.load_iri_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_iri_data(iri_file)</code></pre><p>Load IRI model data from a file into a structured NamedTuple.</p><p>Reads an IRI data file and organizes all columns into a NamedTuple with descriptive field names for easy access to densities, temperatures, and other ionospheric parameters.</p><p><strong>Arguments</strong></p><ul><li><code>iri_file::String</code>: Path to the IRI data file</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: IRI data with the following fields (all vectors except where noted):<ul><li><code>height_km</code>: Altitude grid (km)</li><li><code>ne</code>: Electron density (m⁻³)</li><li><code>Tn</code>: Neutral temperature (K)</li><li><code>Ti</code>: Ion temperature (K)</li><li><code>Te</code>: Electron temperature (K)</li><li><code>nO⁺</code>, <code>nH⁺</code>, <code>nHe⁺</code>, <code>nO2⁺</code>, <code>nNO⁺</code>, <code>nCI</code>, <code>nN⁺</code>: Ion densities (m⁻³)</li><li><code>NmF2</code>, <code>NmF1</code>, <code>NmE</code>: Peak densities at F2, F1, E layers</li><li><code>hmF2</code>, <code>hmF1</code>, <code>hmE</code>: Peak heights at F2, F1, E layers (km)</li><li><code>TEC</code>: Total Electron Content</li><li><code>EqVertIonDrift</code>: Equatorial vertical ion drift</li><li><code>foF2</code>: F2 critical frequency</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>All profile data are vectors with length equal to the iri altitude grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/iri/io.jl#L138-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_msis-Tuple{Any}"><a class="docstring-binding" href="#AURORA.load_msis-Tuple{Any}"><code>AURORA.load_msis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_msis(msis_file)</code></pre><p>Load a MSIS file and return both parameters and data.</p><p><strong>Arguments</strong></p><ul><li><code>msis_file</code>: Path to the MSIS file to load</li></ul><p><strong>Returns</strong></p><p>A NamedTuple with two fields:</p><ul><li><code>parameters</code>: NamedTuple with (year, month, day, hour, minute, lat, lon, height)</li><li><code>data</code>: NamedTuple with all the MSIS data columns</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/msis/io.jl#L67-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_msis_data-Tuple{Any}"><a class="docstring-binding" href="#AURORA.load_msis_data-Tuple{Any}"><code>AURORA.load_msis_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_msis_data(msis_file)</code></pre><p>Load MSIS model data from a file into a structured NamedTuple.</p><p>Reads a MSIS data file and organizes all columns into a NamedTuple with descriptive field names for easy access to densities, temperature, and other atmospheric parameters.</p><p><strong>Arguments</strong></p><ul><li><code>msis_file::String</code>: Path to the MSIS data file</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: MSIS data with the following fields (all vectors):<ul><li><code>height_km</code>: Altitude grid (km)</li><li><code>air</code>: Total mass density (kg/m³)</li><li><code>N2</code>: Molecular nitrogen density (m⁻³)</li><li><code>O2</code>: Molecular oxygen density (m⁻³)</li><li><code>O</code>: Atomic oxygen density (m⁻³)</li><li><code>He</code>: Helium density (m⁻³)</li><li><code>H</code>: Atomic hydrogen density (m⁻³)</li><li><code>Ar</code>: Argon density (m⁻³)</li><li><code>N</code>: Atomic nitrogen density (m⁻³)</li><li><code>anomalousO</code>: Anomalous oxygen density (m⁻³)</li><li><code>NO</code>: Nitric oxide density (m⁻³)</li><li><code>T</code>: Temperature (K)</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>All data are vectors with length equal to the msis altitude grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/msis/io.jl#L138-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_neutral_densities-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.load_neutral_densities-Tuple{Any, Any}"><code>AURORA.load_neutral_densities</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_neutral_densities(msis_file, h_atm)</code></pre><p>Load the neutral densities and temperature from a MSIS file that was generated and saved using AURORA&#39;s MSIS interface. Then interpolate the profiles over AURORA&#39;s altitude grid.</p><p>Upper boundary conditions are applied to smoothly transition the densities to zero.</p><p><strong>Calling</strong></p><p><code>n_neutrals, Tn = load_neutral_densities(msis_file, h_atm)</code></p><p><strong>Inputs</strong></p><ul><li><code>msis_file</code>: absolute path to the msis file to read n_neutrals and Tn from. String</li><li><code>h_atm</code>: altitude (m). Vector [nZ]</li></ul><p><strong>Returns</strong></p><ul><li><code>n_neutrals</code>: neutral densities (m⁻³). Named tuple of vectors ([nZ], ..., [nZ])</li><li><code>Tn</code>: neutral temperature (K). Vector [nZ]</li></ul><p><strong>See also</strong></p><p><a href="#AURORA.load_msis-Tuple{Any}"><code>load_msis</code></a>, <a href="#AURORA.interpolate_msis_to_grid-Tuple{Any, Any}"><code>interpolate_msis_to_grid</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/setup.jl#L186-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_parameters_iri-Tuple{Any}"><a class="docstring-binding" href="#AURORA.load_parameters_iri-Tuple{Any}"><code>AURORA.load_parameters_iri</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_parameters_iri(iri_file)</code></pre><p>Load calculation parameters from an IRI data file header.</p><p>Reads the header section of an IRI file and extracts the input parameters that were used for the IRI model calculation.</p><p><strong>Arguments</strong></p><ul><li><code>iri_file::String</code>: Path to the IRI data file</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: Parameters with fields:<ul><li><code>year::Int</code>: Year</li><li><code>month::Int</code>: Month (1-12)</li><li><code>day::Int</code>: Day (1-31)</li><li><code>hour::Int</code>: Hour (0-23)</li><li><code>minute::Int</code>: Minute (0-59)</li><li><code>lat::Real</code>: Latitude (degrees North)</li><li><code>lon::Real</code>: Longitude (degrees East)</li><li><code>height::AbstractRange</code>: Altitude range (km)</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/iri/io.jl#L87-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_parameters_msis-Tuple{Any}"><a class="docstring-binding" href="#AURORA.load_parameters_msis-Tuple{Any}"><code>AURORA.load_parameters_msis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_parameters_msis(msis_file)</code></pre><p>Load calculation parameters from a MSIS data file header.</p><p>Reads the header section of a MSIS file and extracts the input parameters that were used for the MSIS model calculation.</p><p><strong>Arguments</strong></p><ul><li><code>msis_file::String</code>: Path to the MSIS data file</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: Parameters with fields:<ul><li><code>year::Int</code>: Year</li><li><code>month::Int</code>: Month (1-12)</li><li><code>day::Int</code>: Day (1-31)</li><li><code>hour::Int</code>: Hour (0-23)</li><li><code>minute::Int</code>: Minute (0-59)</li><li><code>lat::Real</code>: Latitude (degrees North)</li><li><code>lon::Real</code>: Longitude (degrees East)</li><li><code>height::AbstractRange</code>: Altitude range (km)</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/msis/io.jl#L87-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.load_scattering_matrices-Tuple{Any}"><a class="docstring-binding" href="#AURORA.load_scattering_matrices-Tuple{Any}"><code>AURORA.load_scattering_matrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_scattering_matrices(θ_lims)</code></pre><p>Create an energy grid based on the maximum energy <code>E_max</code> given as input.</p><p><strong>Calling</strong></p><p><code>μ_lims, μ_center, μ_scatterings = load_scattering_matrices(θ_lims)</code></p><p><strong>Inputs</strong></p><ul><li><code>θ_lims</code>: pitch angle limits of the e- beams (deg). Vector [n_beam + 1]</li></ul><p><strong>Outputs</strong></p><ul><li><code>μ_lims</code>: cosine of the pitch angle limits of the e- beams. Vector [n_beam + 1]</li><li><code>μ_center</code>: cosine of the pitch angle of the middle of the e- beams. Vector [n_beam]</li><li><code>μ_scatterings</code>: Tuple with several of the scattering informations, namely μ<code>_</code>scatterings   = <code>(Pmu2mup, BeamWeight_relative, BeamWeight)</code><ul><li><code>Pmu2mup</code>: probabilities for scattering in 3D from beam to beam. Matrix [n<code>_</code>direction x n<code>_</code>direction]</li><li><code>BeamWeight_relative</code>: relative contribution from within each beam. Matrix [n<code>_</code>beam x n<code>_</code>direction]</li><li><code>BeamWeight</code>: solid angle for each stream (ster). Vector [n_beam]</li><li><code>theta1</code>: scattering angles used in the calculations. Vector [n_direction]</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/setup.jl#L119-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.loss_to_thermal_electrons-Tuple{Real, Any, Any}"><a class="docstring-binding" href="#AURORA.loss_to_thermal_electrons-Tuple{Real, Any, Any}"><code>AURORA.loss_to_thermal_electrons</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loss_to_thermal_electrons(E, ne, Te)</code></pre><p>Suprathermal electron energy loss function due to electron-electron collisions.</p><p>This function calculates the electron energy loss function due to electron-electron interaction. It uses the analytic form given for the energy-transfer rate from photoelectrons (or suprathermal electrons) to thermal electrons, given by Swartz and Nisbet (1971). The expression fits the classical formulation of Itikawa and Aono (1966) at low energies and gives a smooth transition to fit the quantum mechanical equation of Schunk and Hays (1971).</p><p><strong>Arguments</strong></p><ul><li><code>E::Real</code>: Energy level [eV]. Scalar value.</li><li><code>ne::Vector</code>: Ambient electron concentration [/m³], length nZ.</li><li><code>Te::Vector</code>: Electron temperature [K], length nZ.</li></ul><p><strong>Returns</strong></p><ul><li><code>Le::Vector</code>: Electron energy loss function [eV/m], length nZ.</li></ul><p><strong>Notes</strong></p><p>The paper by Swartz and Nisbet uses electron density in cm⁻³; here the constant is rescaled to use m⁻³ instead. We calculate the loss function dE/ds(E,ne,Te) directly and not as in Swartz and Nisbet dE/ds(E,ne,Te)/ne.</p><p>The loss is set to zero when the suprathermal electron energy E is below the thermal electron energy Ee = kB*Te/qₑ.</p><p><strong>References</strong></p><ul><li>Swartz, W. E., J. S. Nisbet, and A. E. S. Green (1971), Analytic expression for the energy transfer rate from photoelectrons to thermal electrons, J. Geophys. Res., 76(34), 8425-8426, doi: 10.1029/JA076i034p08425.</li><li>Itikawa, Y., and O. Aono (1966), Energy change of a charged particle moving in a plasma, Phys. Fluids, 9, 1259-1261.</li><li>Schunk, R. W., and P. B. Hays (1971), Photoelectron energy losses to thermal electrons, Planet. Space Sci., 19, 113-117.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/matrix_building.jl#L46-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.make_Ie_top_file-Tuple{Any}"><a class="docstring-binding" href="#AURORA.make_Ie_top_file-Tuple{Any}"><code>AURORA.make_Ie_top_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_Ie_top_file(directory_to_process)</code></pre><p>Reads into a folder <code>directory_to_process</code> containing results from an AURORA.jl simulation and extracts the particle flux <code>Ie</code> (#e⁻/m²/s) at the top of the ionosphere (i.e. at the max altitude used in the simulation).</p><p><strong>Calling</strong></p><p><code>make_Ie_top_file(directory_to_process)</code></p><p><strong>Inputs</strong></p><ul><li><code>directory_to_process</code>: absolute or relative path to the simulation directory to process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L571-L583">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.make_altitude_grid-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.make_altitude_grid-Tuple{Any, Any}"><code>AURORA.make_altitude_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_altitude_grid(bottom_altitude, top_altitude)</code></pre><p>Create an altitude grid based on the altitude limits given as input. It uses constant steps of 150m for altitudes below 100km, and a non-linear grid above 100km.</p><p><strong>Calling</strong></p><p>`h<em>atm = make</em>altitude<em>grid(bottom</em>altitude, top_altitude)</p><p><strong>Inputs</strong></p><ul><li><code>top_altitude</code>: the altitude, in km, for the top of the ionosphere in our simulation</li><li><code>bottom_altitude</code>: the altitude, in km, for the bottom of the ionosphere in our simulation</li></ul><p><strong>Outputs</strong></p><ul><li><code>h_atm</code>: altitude (m). Vector [nZ]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/setup.jl#L61-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.make_column_excitation_file-Tuple{Any}"><a class="docstring-binding" href="#AURORA.make_column_excitation_file-Tuple{Any}"><code>AURORA.make_column_excitation_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_column_excitation_file(directory_to_process)</code></pre><p>Reads into a folder <code>directory_to_process</code> containing results from an AURORA.jl simulation, loads the volume excitation rates <code>Q_XXXX</code> (#excitation/m³/s) contained in the file <code>Qzt_all_L.mat</code> and integrate them in height, taking into account the finite speed of light.</p><p>The calculated colum-integrated excitation rates are saved to a file named <code>I_lambda_of_t.mat</code>. The column-integrated excitation rates are named &quot;I_4278, I_6730, ...&quot;. They are all vectors in time (length n_t), and have units of (#excitation/m²/s).</p><p>Note that the function <code>make_volume_excitation_file()</code> needs to be run before this one, as we need the file <code>Qzt_all_L.mat</code> with the volume excitation rates.</p><p><strong>Calling</strong></p><p><code>make_current_file(directory_to_process)</code></p><p><strong>Inputs</strong></p><ul><li><code>directory_to_process</code>: absolute or relative path to the simulation directory to process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L365-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.make_current_file-Tuple{Any}"><a class="docstring-binding" href="#AURORA.make_current_file-Tuple{Any}"><code>AURORA.make_current_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_current_file(directory_to_process)</code></pre><p>Reads into a folder <code>directory_to_process</code> containing results from an AURORA.jl simulation, loads the particle flux <code>Ie</code> (#e⁻/m²/s) and calculates the field-aligned current-density and field-aligned energy-flux for each height and through time.</p><p>The following variables are saved to a file named <em>J.mat</em>:</p><ul><li><code>J_up</code>: Field-aligned current-density in the upward direction. 2D array [n_z, n_t]</li><li><code>J_down</code>: Field-aligned current-density in the downward direction. 2D array [n_z, n_t]</li><li><code>E_up</code>: Field-aligned energy-flux (eV/m²/s) in the upward direction. 2D array [n_z, n_t]</li><li><code>E_down</code>: Field-aligned energy-flux (eV/m²/s) in the downward direction. 2D array [n_z, n_t]</li></ul><p><strong>Calling</strong></p><p><code>make_current_file(directory_to_process)</code></p><p><strong>Inputs</strong></p><ul><li><code>directory_to_process</code>: absolute or relative path to the simulation directory to process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L661-L679">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.make_density_file-Tuple{Any}"><a class="docstring-binding" href="#AURORA.make_density_file-Tuple{Any}"><code>AURORA.make_density_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_density_file(directory_to_process)</code></pre><p>This function reads into a folder <code>directory_to_process</code> containing results from an AURORA.jl simulation. It loads the particle flux <code>Ie</code> (#e⁻/m²/s), calculates the superthermal e- density <code>n_e</code> (#e⁻/m³) from it, and saves <code>n_e</code> into a new file &quot;superthermal_e_density.mat&quot;.</p><p>The particle flux <code>Ie</code> is defined along a magnetic field line and over an (Energy, pitch_angle)-grid. The number density <code>n_e</code> calculated is given along a magnetic field line and over an energy grid. That way, we have the density of electrons with a certain energy at a specific altitude and time.</p><p><strong>Calling</strong></p><p><code>make_density_file(directory_to_process)</code></p><p><strong>Inputs</strong></p><ul><li><code>directory_to_process</code>: absolute or relative path to the simulation directory to process</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L8-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.make_energy_grid-Tuple{Any}"><a class="docstring-binding" href="#AURORA.make_energy_grid-Tuple{Any}"><code>AURORA.make_energy_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_energy_grid(E_max)</code></pre><p>Create an energy grid based on the maximum energy <code>E_max</code> given as input.</p><p><strong>Calling</strong></p><p><code>E, dE = make_energy_grid(E_max)</code></p><p><strong>Inputs</strong></p><ul><li><code>E_max</code>: upper limit for the energy grid (in eV)</li></ul><p><strong>Outputs</strong></p><ul><li><code>E</code>: energy grid (eV). Vector [nE]</li><li><code>dE</code>: energy bin sizes(eV). Vector [nE]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/setup.jl#L90-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.make_heating_rate_file-Tuple{Any}"><a class="docstring-binding" href="#AURORA.make_heating_rate_file-Tuple{Any}"><code>AURORA.make_heating_rate_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_heating_rate_file(directory_to_process)</code></pre><p>Reads into a folder <code>directory_to_process</code> containing results from an AURORA.jl simulation, loads the particle flux <code>Ie</code> (#e⁻/m²/s), and calculates the heating rate of thermal electrons by superthermal electrons.</p><p>The heating rate is the rate at which energy is transferred from superthermal electrons to thermal electrons through Coulomb collisions. It is saved as a function of altitude and time.</p><p><strong>Calling</strong></p><p><code>make_heating_rate_file(directory_to_process)</code></p><p><strong>Inputs</strong></p><ul><li><code>directory_to_process</code>: absolute or relative path to the simulation directory to process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L860-L875">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.make_savedir-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.make_savedir-Tuple{Any, Any}"><code>AURORA.make_savedir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_savedir(root_savedir, name_savedir; behavior = &quot;default&quot;)</code></pre><p>Return the path to the directory where the results will be saved. If the directory does not already exist, create it.</p><p>If the constructed <code>savedir</code> already exists and contains files starting with <code>&quot;IeFlickering-&quot;</code>, a new directory is created to avoid accidental overwriting of results (e.g., <code>savedir(1)</code>, <code>savedir(2)</code>, etc.).</p><p><strong>Calling</strong></p><p><code>savedir = make_savedir(root_savedir, name_savedir)</code> <br/><code>savedir = make_savedir(root_savedir, name_savedir; behavior = &quot;custom&quot;)</code></p><p><strong>Arguments</strong></p><ul><li><code>root_savedir::String</code>: The root directory where the data will be saved. If empty or   contains only spaces, it defaults to <code>&quot;backup&quot;</code>.</li><li><code>name_savedir::String</code>: The name of the subdirectory to be created within <code>root_savedir</code>.   If empty or contains only spaces, it defaults to the current date and time in the   format <code>&quot;yyyymmdd-HHMM&quot;</code>.</li><li><code>behavior::String</code> (optional): Determines how the full path is constructed.<ul><li><code>&quot;default&quot;</code>: The path will be built starting under the <code>data/</code> folder of the AURORA installation   (i.e., <code>AURORA_folder/data/root_savedir/name_savedir/</code>, where <code>AURORA_folder</code> is   the folder containing the AURORA code). This is the default behavior.</li><li><code>&quot;custom&quot;</code>: The path will be built as <code>root_savedir/name_savedir/</code>, with the argument   <code>root_savedir</code> treated as an absolute or relative path. This allows for saving results   in any location on the system. Useful if AURORA is installed as a dependency to some   other project.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>savedir::String</code>: The full path to the directory where the results will be saved.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/utilities.jl#L241-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.make_volume_excitation_file-Tuple{Any}"><a class="docstring-binding" href="#AURORA.make_volume_excitation_file-Tuple{Any}"><code>AURORA.make_volume_excitation_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_volume_excitation_file(directory_to_process)</code></pre><p>Reads into a folder <code>directory_to_process</code> containing results from an AURORA.jl simulation, loads the particle flux <code>Ie</code> (#e⁻/m²/s), and calculates the volume-excitation-rates. For prompt emissions, volume-excitation-rates correspond also to volume-emission-rates.</p><p><strong>Calling</strong></p><p><code>make_volume_excitation_file(directory_to_process)</code></p><p><strong>Inputs</strong></p><ul><li><code>directory_to_process</code>: absolute or relative path to the simulation directory to process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L137-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.mu_avg-Tuple{Any}"><a class="docstring-binding" href="#AURORA.mu_avg-Tuple{Any}"><code>AURORA.mu_avg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mu_avg(θ_lims)</code></pre><p>Calculate the cosinus of the center of each pitch-angle beams delimited by θ_lims. This is for isotropically distributed fluxes within each beam, i.e the fluxes are weighted by sin(θ)</p><p><strong>Calling</strong></p><p><code>μ_center = mu_avg(θ_lims)</code></p><p><strong>Inputs</strong></p><ul><li><code>θ_lims</code> : pitch-angle limits <em>in degrees</em> of all the beams, range or vector [n_beams + 1]</li></ul><p><strong>Outputs</strong></p><ul><li><code>μ_center</code> : cosine of the center of all the pitch-angle beams, vector [n_beams + 1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/utilities.jl#L51-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.q2colem"><a class="docstring-binding" href="#AURORA.q2colem"><code>AURORA.q2colem</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">q2colem(t::Real, h_atm, Q, A = 1, τ = ones(length(h_atm)))</code></pre><p>Same as above, except time is now a scalar (steady-state results). This is just a simple integration in height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L540-L545">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.q2colem"><a class="docstring-binding" href="#AURORA.q2colem"><code>AURORA.q2colem</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">q2colem(t::Vector, h_atm, Q, A = 1, τ = ones(length(h_atm)))</code></pre><p>Integrate the volume-excitation-rate (#exc/m³/s) to column-excitation-rate (#exc/m²/s).</p><p>Takes into account the time-delay between light emitted at different altitudes. Photons emitted at at altitude of 200km will arrive at the detector 100e3/3e8 = 0.333 ms later than electrons emitted at an altitude of 100km. This is a small time-shift, but it is close to the time-differences corresponding to the phase-shifts between auroral emissions varying at ~10Hz.</p><p>The einstein coefficient <code>A</code> and effective lifetime <code>τ</code> are optional (equal to one by default).</p><p><strong>Calling</strong></p><p><code>I = q2colem(t, h_atm, Q, A, τ)</code></p><p><strong>Inputs</strong></p><ul><li><code>h_atm</code>: altitude (m). Vector [n_z]</li><li><code>t</code>: time (s). Vector [n_t]</li><li><code>Q</code>: volume-excitation-rate (#exc/m³/s) of the wavelength of interest. 2D array [n_z, n_t]</li><li><code>A</code>: einstein coefficient (s⁻¹). Scalar (Float or Int)</li><li><code>τ</code>: effective lifetime (s). Vector [n_z].</li></ul><p><strong>Output</strong></p><ul><li><code>I</code>: integrated column-excitation-rate (#exc/m²/s) of the wavelength of interest. Vector [n_t]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/analysis.jl#L439-L464">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.rename_if_exists-Tuple{Any}"><a class="docstring-binding" href="#AURORA.rename_if_exists-Tuple{Any}"><code>AURORA.rename_if_exists</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rename_if_exists(savefile)</code></pre><p>This function takes a string as an input. If a file or folder with that name <em>does not</em> exist, it returns the same string back. But if the folder or file already exists, it appends a number between parenthesis to the name string.</p><p>For example, if the folder <code>foo/</code> already exist and <code>&quot;foo&quot;</code> is given as input, the function will return a string <code>&quot;foo(1)&quot;</code> as an output. Similarly, if a file <code>foo.txt</code> already exists and <code>&quot;foo.txt&quot;</code> is given as input, the function will return a string <code>&quot;foo(1).txt&quot;</code>. If the file <code>foo(1).txt</code> also already exist, the function will return a string <code>&quot;foo(2).txt&quot;</code>, etc...</p><p>The function should support all types of extensions.</p><p><strong>Calling</strong></p><p><code>newsavefile = rename_if_exists(savefile)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/utilities.jl#L170-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.restructure_streams_of_Ie-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#AURORA.restructure_streams_of_Ie-Tuple{Any, Any, Any}"><code>AURORA.restructure_streams_of_Ie</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">restructure_streams_of_Ie(Ie, θ_lims, new_θ_lims)</code></pre><p>Function that merges the streams of <code>Ie</code> that are given over <code>θ_lims</code> to fit the <code>new_θ_lims</code> of interest. It can be useful when wanting to merge some streams for plotting.</p><p>For example, if we have <code>θ_lims = [180 160 140 120 100 90 80 60 40 20 0]</code>, and we want to plot with <code>new_θ_lims = [(180, 160), (160, 120)]</code>, the function will keep the first stream as is and merge the streams (160°-140°) and (140°-120°) together into a new stream with limits (160°-120°).</p><p><em>Important</em>: The limits in <code>new_θ_lims</code> need to match some existing limits in <code>θ_lims</code>. In the example above, <code>new_θ_lims = [(180, 165)]</code> would not have worked because 165° is not a limit that exists in <code>θ_lims</code>.</p><p>Entries in <code>new_θ_lims</code> can be <code>nothing</code> to leave a panel empty.</p><p><strong>Calling</strong></p><p><code>Ie_plot = restructure_streams_of_Ie(Ie, θ_lims, new_θ_lims)</code></p><p><strong>Arguments</strong></p><ul><li><code>Ie</code>: array of electron flux with pitch-angle limits <code>θ_lims</code>. Of shape [n_μ, n_z, n_t, n_E].</li><li><code>θ_lims</code>: pitch-angle limits. Usually a vector or range.</li><li><code>new_θ_lims</code>: new pitch-angle limits. Given as an array of tuples with angles in the range               0-180° (where 180° is field-aligned down, 0° is field-aligned up). Use <code>nothing</code>               for empty panels. For example:</li></ul><pre><code class="language-julia hljs">julia&gt; new_θ_lims = [(180, 170)  (170, 150)  (150, 120)  (120, 100)  (100, 90);  # DOWN
                     (0, 10)     (10, 30)    (30, 60)    (60, 80)    (80, 90)]   # UP</code></pre><p><strong>Returns</strong></p><ul><li><code>Ie_plot</code>: array of electron flux with the new pitch-angle limits <code>new_θ_lims</code>. Of shape            [n_μ_new, n_z, n_t, n_E], where n_μ_new is the number of streams            in <code>new_θ_lims</code>. The first dimension of <code>Ie_plot</code> is sorted such that the            indices go along the first row of <code>new_θ_lims</code>, and then the second row.            In our example with <code>new_θ_lims</code> from above, that would be <span>$[1 2 3 4 5; 6 7 8 9 10]$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/utilities.jl#L360-L398">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.save_cascading_matrices-NTuple{5, Any}"><a class="docstring-binding" href="#AURORA.save_cascading_matrices-NTuple{5, Any}"><code>AURORA.save_cascading_matrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_cascading_matrices(Q_transfer_matrix, E_grid_for_Q, ionization_thresholds, species_dir, species_name)</code></pre><p>Save calculated cascading matrices to a file.</p><p><strong>Arguments</strong></p><ul><li><code>Q_transfer_matrix</code>: Transfer matrix to save</li><li><code>E_grid_for_Q</code>: Energy grid used for calculations</li><li><code>ionization_thresholds</code>: Ionization threshold energies</li><li><code>species_dir</code>: Directory to save the file</li><li><code>species_name</code>: Name of the species (for filename)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/cascading.jl#L74-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.save_iri_data-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.save_iri_data-Tuple{Any, Any}"><code>AURORA.save_iri_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_iri_data(iri_data, parameters)</code></pre><p>Save IRI model data to a text file with metadata header.</p><p>Creates a formatted text file containing the IRI calculation parameters in the header followed by the data matrix. The filename is automatically generated based on the input parameters, and if a file with the same name exists, a unique name is created.</p><p><strong>Arguments</strong></p><ul><li><code>iri_data::Matrix</code>: IRI data matrix from <code>calculate_iri_data()</code> (with header row)</li><li><code>parameters::NamedTuple</code>: Parameters used for IRI calculation, must contain:<ul><li><code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>: Time specification</li><li><code>lat</code>, <code>lon</code>: Location (degrees)</li><li><code>height</code>: Altitude range (km)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Full path to the created file</li></ul><p><strong>File Format</strong></p><p>The file contains:</p><ol><li>Header section with input parameters</li><li>Column headers</li><li>Data matrix (one row per altitude)</li></ol><p><strong>Filename Convention</strong></p><p><code>iri_YYYYMMDD-HHMM_LATN-LONE.txt</code></p><p><strong>Notes</strong></p><ul><li>Files are saved to <code>internal_data/data_electron/</code> directory</li><li>Existing files are not overwritten; a suffix is added to the filename</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/iri/io.jl#L205-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.save_msis_data-Tuple{Any, Any}"><a class="docstring-binding" href="#AURORA.save_msis_data-Tuple{Any, Any}"><code>AURORA.save_msis_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_msis_data(msis_data, parameters)</code></pre><p>Save MSIS model data to a text file with metadata header.</p><p>Creates a formatted text file containing the MSIS calculation parameters in the header followed by the data matrix. The filename is automatically generated based on the input parameters, and if a file with the same name exists, a unique name is created.</p><p><strong>Arguments</strong></p><ul><li><code>msis_data::Matrix</code>: MSIS data matrix from <code>calculate_msis_data()</code> (with header row)</li><li><code>parameters::NamedTuple</code>: Parameters used for MSIS calculation, must contain:<ul><li><code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>: Time specification</li><li><code>lat</code>, <code>lon</code>: Location (degrees)</li><li><code>height</code>: Altitude range (km)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Full path to the created file</li></ul><p><strong>File Format</strong></p><p>The file contains:</p><ol><li>Header section with input parameters</li><li>Column headers</li><li>Data matrix (one row per altitude)</li></ol><p><strong>Filename Convention</strong></p><p><code>msis_YYYYMMDD-HHMM_LATN-LONE.txt</code></p><p><strong>Notes</strong></p><ul><li>Files are saved to <code>internal_data/data_neutrals/</code> directory</li><li>Existing files are not overwritten; a suffix is added to the filename</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/msis/io.jl#L197-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.search_existing_iri_file-Tuple{}"><a class="docstring-binding" href="#AURORA.search_existing_iri_file-Tuple{}"><code>AURORA.search_existing_iri_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">search_existing_iri_file(; year, month, day, hour, minute, lat, lon, height)</code></pre><p>Search for an existing IRI data file matching the specified parameters.</p><p>This function scans the <code>internal_data/data_electron/</code> directory for IRI files with matching time, location, and altitude grid parameters. It performs a quick pre-check on filenames before loading and comparing full parameters.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>year::Int</code>: Year</li><li><code>month::Int</code>: Month (1-12)</li><li><code>day::Int</code>: Day of month (1-31)</li><li><code>hour::Int</code>: Hour in Universal Time (0-23)</li><li><code>minute::Int</code>: Minute (0-59)</li><li><code>lat::Real</code>: Geographic latitude in degrees North</li><li><code>lon::Real</code>: Geographic longitude in degrees East</li><li><code>height::AbstractRange</code>: Altitude range in km</li></ul><p><strong>Returns</strong></p><ul><li><code>Union{String, Nothing}</code>: Full path to matching file, or <code>nothing</code> if not found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/iri/io.jl#L8-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.search_existing_msis_file-Tuple{}"><a class="docstring-binding" href="#AURORA.search_existing_msis_file-Tuple{}"><code>AURORA.search_existing_msis_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">search_existing_msis_file(; year, month, day, hour, minute, lat, lon, height)</code></pre><p>Search for an existing MSIS data file matching the specified parameters.</p><p>This function scans the <code>internal_data/data_neutrals/</code> directory for MSIS files with matching time, location, and altitude grid parameters. It performs a quick pre-check on filenames before loading and comparing full parameters.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>year::Int</code>: Year</li><li><code>month::Int</code>: Month (1-12)</li><li><code>day::Int</code>: Day of month (1-31)</li><li><code>hour::Int</code>: Hour in Universal Time (0-23)</li><li><code>minute::Int</code>: Minute (0-59)</li><li><code>lat::Real</code>: Geographic latitude in degrees North</li><li><code>lon::Real</code>: Geographic longitude in degrees East</li><li><code>height::AbstractRange</code>: Altitude range in km</li></ul><p><strong>Returns</strong></p><ul><li><code>Union{String, Nothing}</code>: Full path to matching file, or <code>nothing</code> if not found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/msis/io.jl#L8-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.setup-NTuple{5, Any}"><a class="docstring-binding" href="#AURORA.setup-NTuple{5, Any}"><code>AURORA.setup</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setup(altitude_lims, θ_lims, E_max, msis_file, iri_file)</code></pre><p>Load the atmosphere, the energy grid, the collision cross-sections, ...</p><p><strong>Calling</strong></p><p><code>h_atm, ne, Te, Tn, E, dE, n_neutrals, E_levels_neutrals, σ_neutrals, θ_lims, μ_lims, μ_center, μ_scatterings = setup(altitude_lims, θ_lims, E_max, msis_file, iri_file)</code></p><p><strong>Inputs</strong></p><ul><li><code>altitude_lims</code>: the altitude limits, in km, for the bottom and top of the ionosphere in our simulation</li><li><code>θ_lims</code>: pitch-angle limits of the electron beams (e.g. 180:-10:0), where 180°   corresponds to field aligned down, and 0° field aligned up. Vector [n_beam]</li><li><code>E_max</code>: upper limit for the energy grid (in eV)</li><li><code>msis_file</code>: path to the msis file to use</li><li><code>iri_file</code>: path to the iri file to use</li></ul><p><strong>Outputs</strong></p><ul><li><code>h_atm</code>: altitude (m). Vector [nZ]</li><li><code>ne</code>: e- density (m⁻³). Vector [nZ]</li><li><code>Te</code>: e- temperature (K). Vector [nZ]</li><li><code>Tn</code>: neutral temperature (K). Vector [nZ]</li><li><code>E</code>: energy grid (eV). Vector [nE]</li><li><code>dE</code>: energy bin sizes(eV). Vector [nE]</li><li><code>n_neutrals</code>: neutral densities (m⁻³). Named tuple of vectors ([nZ], ..., [nZ])</li><li><code>E_levels_neutrals</code>: collisions energy levels and number of secondary e- produced. Named   tuple of matrices ([n<code>_</code>levels x 2], ..., [n<code>_</code>levels x 2])</li><li><code>σ_neutrals</code>: collision cross-sections (m⁻²). Named tuple of matrices ([n<code>_</code>levels x nE],   ..., [n<code>_</code>levels x nE])</li><li><code>θ_lims</code>: pitch angle limits of the e- beams (deg). Vector [n_beam + 1]</li><li><code>μ_lims</code>: cosine of the pitch angle limits of the e- beams. Vector [n_beam + 1]</li><li><code>μ_center</code>: cosine of the pitch angle of the middle of the e- beams. Vector [n_beam]</li><li><code>μ_scatterings</code>: Named tuple with several of the scattering informations, namely   μ<code>_</code>scatterings = <code>(Pmu2mup, BeamWeight_relative, BeamWeight)</code><ul><li><code>Pmu2mup</code>: probabilities for scattering in 3D from beam to beam. Matrix [n<code>_</code>direction x n<code>_</code>direction]</li><li><code>BeamWeight_relative</code>: relative contribution from within each beam. Matrix [n<code>_</code>beam x n<code>_</code>direction]</li><li><code>BeamWeight</code>: solid angle for each stream (ster). Vector [n_beam]</li><li><code>theta1</code>: scattering angles used in the calculations. Vector [n_direction]</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/setup.jl#L6-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.steady_state_scheme_optimized!-NTuple{7, Any}"><a class="docstring-binding" href="#AURORA.steady_state_scheme_optimized!-NTuple{7, Any}"><code>AURORA.steady_state_scheme_optimized!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">steady_state_scheme_optimized!(Ie, h_atm, μ, matrices, iE, Ie_top, cache; first_iteration = false)</code></pre><p>Optimized steady-state scheme using direct nzval modification. This is an in-place version that modifies <code>Ie</code> directly to avoid allocations. This version avoids allocations by reusing the sparse matrix structure.</p><p>On first iteration, creates the sparsity pattern and mapping which are stored in cache. On subsequent iterations, only updates the nzval array directly.</p><p><strong>Mathematical Background</strong></p><p>The steady-state electron transport equation is:</p><pre><code class="language-julia hljs">μ ∂Ie/∂z + A*Ie - ∫B*Ie&#39;dΩ&#39; = Q</code></pre><p>After spatial discretization, this becomes a linear system of coupled equations:</p><pre><code class="language-julia hljs">[μ*Ddz + A - B - D*Ddiffusion] * Ie = Q
         ↑
        Mlhs (the system matrix)</code></pre><p>Where:</p><ul><li><code>Ddz = Ddz_Up</code> or <code>Ddz_Down</code> (depending on sign of μ): spatial derivative operator</li><li><code>A</code>: electron loss rate matrix (diagonal)</li><li><code>B</code>: scattering operator matrix (couples different angles)</li><li><code>D</code>: diffusion coefficient (diagonal in angle space)</li><li><code>Ddiffusion</code>: second derivative operator for pitch-angle diffusion</li><li><code>Q</code>: source term (energy degradation and ionization)</li></ul><p>The resulting sparse matrix <code>Mlhs</code> has a block structure:</p><pre><code class="language-julia hljs">┌─────────┬─────────┬─────────┐
│ Block   │ Block   │ Block   │  Each block is n_z × n_z
│ (1,1)   │ (1,2)   │ (1,3)   │  (n_z = number of altitudes)
├─────────┼─────────┼─────────┤
│ Block   │ Block   │ Block   │  Off-diagonal blocks (i1≠i2):
│ (2,1)   │ (2,2)   │ (2,3)   │  represent angular scattering (B matrix)
├─────────┼─────────┼─────────┤
│ Block   │ Block   │ Block   │  Diagonal blocks (i1=i2):
│ (3,1)   │ (3,2)   │ (3,3)   │  transport + loss + diffusion
└─────────┴─────────┴─────────┘</code></pre><p>In the context of solving <code>f(Ie) = Mlhs*Ie - Q = 0</code>, the matrix <code>Mlhs</code> is the Jacobian:</p><pre><code class="language-julia hljs">Jacobian = ∂f/∂Ie = Mlhs</code></pre><p><strong>Arguments</strong></p><ul><li><code>Ie</code>: pre-allocated output array [m⁻² s⁻¹] (n<em>z * n</em>angle) to store results</li><li><code>h_atm</code>: altitude grid [km]</li><li><code>μ</code>: cosine of pitch angle grid</li><li><code>matrices::TransportMatrices</code>: container with<ul><li><code>A</code>: electron loss rate [s⁻¹]</li><li><code>B</code>: scattering matrix [s⁻¹] (n<em>z × n</em>angle × n_angle)</li><li><code>D</code>: pitch-angle diffusion coefficient [s⁻¹] (n_angle,)</li><li><code>Q</code>: source term [m⁻² s⁻¹] at each time step</li><li><code>Ddiffusion</code>: spatial diffusion matrix (n<em>z × n</em>z)</li></ul></li><li><code>iE</code>: current energy index</li><li><code>Ie_top</code>: boundary condition at top [m⁻² s⁻¹]</li><li><code>cache</code>: Cache object storing Mlhs, mapping, KLU, and differentiation matrices</li><li><code>first_iteration</code>: whether this is the first call (creates structure) or subsequent (reuses structure)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/steady_state_optimized.jl#L323-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.update_crank_nicolson_matrices!-NTuple{13, Any}"><a class="docstring-binding" href="#AURORA.update_crank_nicolson_matrices!-NTuple{13, Any}"><code>AURORA.update_crank_nicolson_matrices!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_crank_nicolson_matrices!(Mlhs, Mrhs, mapping_lhs, mapping_rhs,
                                A, B, D, Ddt, Ddiffusion, Ddz_Up, Ddz_Down, μ, h_atm)</code></pre><p>Update both Mlhs and Mrhs using pre-computed mappings. This is the fast path with zero allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/crank_nicolson_optimized.jl#L277-L283">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.update_matrices!-Tuple{AURORA.TransportMatrices, Vararg{Any, 11}}"><a class="docstring-binding" href="#AURORA.update_matrices!-Tuple{AURORA.TransportMatrices, Vararg{Any, 11}}"><code>AURORA.update_matrices!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_matrices!(matrices, n_neutrals, σ_neutrals, ne, Te, E_levels_neutrals,
                 phase_fcn_neutrals, E, dE, iE, B2B_fragment, finer_θ)</code></pre><p>Update the A and B matrices in place for a given energy level iE.</p><p><strong>Arguments</strong></p><ul><li><code>matrices::TransportMatrices</code>: Container to update</li><li><code>n_neutrals, σ_neutrals, ne, Te, E_levels_neutrals, phase_fcn_neutrals</code>: Atmosphere and cross section data</li><li><code>E, dE, iE</code>: Energy grid and current energy index</li><li><code>B2B_fragment, finer_θ</code>: Pre-computed beam-to-beam fragments and angle grid</li></ul><p><strong>Returns</strong></p><ul><li><code>B2B_inelastic_neutrals</code>: Array of inelastic beam-to-beam matrices for cascading calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/matrix_building.jl#L257-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.update_steady_state_matrix!-NTuple{10, Any}"><a class="docstring-binding" href="#AURORA.update_steady_state_matrix!-NTuple{10, Any}"><code>AURORA.update_steady_state_matrix!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_steady_state_matrix!(Mlhs, mapping, A, B, D, Ddiffusion, Ddz_Up, Ddz_Down, μ, h_atm)</code></pre><p>Update the sparse matrix values using pre-computed mapping. This avoids all allocations by directly modifying nzval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/steady_state_optimized.jl#L207-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.v_of_E-Tuple{Any}"><a class="docstring-binding" href="#AURORA.v_of_E-Tuple{Any}"><code>AURORA.v_of_E</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">v_of_E(E)</code></pre><p>Calculate the velocity (in <strong>m/s</strong>) of an electron with energy <code>E</code> (in <strong>eV</strong>).</p><p><strong>Calling</strong></p><p><code>v = v_of_E(E)</code></p><p><strong>Input</strong></p><ul><li><code>E</code> : energy in <strong>eV</strong>, can be a scalar, vector, range, ...</li></ul><p><strong>Output</strong></p><ul><li><code>v</code> : velocity in <strong>m/s</strong></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/utilities.jl#L9-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AURORA.validate_θ_lims-Tuple{Any}"><a class="docstring-binding" href="#AURORA.validate_θ_lims-Tuple{Any}"><code>AURORA.validate_θ_lims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_θ_lims(θ_lims)</code></pre><p>Validate that the pitch-angle limits <code>θ_lims</code> are correctly specified. Throws an <code>ArgumentError</code> if:</p><ul><li><code>θ_lims</code> does not include 180° (field-aligned downward)</li><li><code>θ_lims</code> does not include 0° (field-aligned upward)</li><li><code>θ_lims</code> is not in descending order</li></ul><p><strong>Inputs</strong></p><ul><li><code>θ_lims</code>: pitch-angle limits of the electron beams (e.g. 180:-10:0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/egavazzi/AURORA.jl/blob/f92ac7316f384909bb9a2c6aa581f160bcd21d86/src/setup.jl#L154-L165">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../90-api/">« API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 12 January 2026 12:13">Monday 12 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
