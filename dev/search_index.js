var documenterSearchIndex = {"docs":
[{"location":"20-api/input_flux/#Input-Flux","page":"Input Flux","title":"Input Flux","text":"","category":"section"},{"location":"20-api/input_flux/#Load-from-file","page":"Input Flux","title":"Load from file","text":"","category":"section"},{"location":"20-api/input_flux/#Analytical-flux","page":"Input Flux","title":"Analytical flux","text":"","category":"section"},{"location":"20-api/input_flux/#AURORA.Ie_top_from_file-20-api-input_flux","page":"Input Flux","title":"AURORA.Ie_top_from_file","text":"Ie_top_from_file(t, E, μ_center, filename; interpolation=:constant)\n\nLoad a time-dependent electron flux from a .mat file and resample it onto the simulation time grid t.\n\nArguments\n\nt: full simulation time grid (s). Range or Vector [n_t]\nE: energy grid (eV). Vector [n_E]\nμ_center: electron beams average pitch angle cosine. Vector [n_μ]\nfilename: path to the .mat file containing the flux data\n\nKeyword Arguments\n\ninterpolation=: interpolation scheme used to resample the file's time grid onto the simulation time grid. Either:\n:constant (default): each file value is held constant until the next sample.\n:linear: linear interpolation between consecutive file samples.\n\nReturns\n\nIe_top: electron number flux (#e⁻/m²/s). Array [nμ, nt, n_E]\n\nFile format\n\nThe .mat file must contain:\n\nIe_total: flux array of shape [n_μ, n_t_file, n_E]\nt_top: time grid (s) of the file, as a vector [n_t_file]. Optional when n_t_file == 1.\n\nTime grid handling\n\nThe file's time grid (t_top) does not need to match the simulation time grid. Any combination of time step sizes and grid lengths is supported:\n\nDifferent dt: the file is resampled onto the simulation grid via interpolation.\nFile finer than simulation: the flux is point-sampled, which may miss rapid variations.\nFile shorter than simulation: flux is set to zero for times beyond t_top[end].\nFile longer than simulation: the file is simply evaluated up to t[end].\n\nNotes\n\nUpward-going beams (μ_center > 0) are always set to zero.\nThe energy dimension of the file may be larger than length(E); only the first length(E) bins are used. It cannot be smaller.\n\n\n\n\n\n","category":"function"},{"location":"20-api/input_flux/#AURORA.Ie_top_modulated-20-api-input_flux","page":"Input Flux","title":"AURORA.Ie_top_modulated","text":"Ie_top_modulated(IeE_tot, E, dE, μ_center, Beams, BeamWeight, t, n_loop, h_atm;\n                 spectrum=:flat, E_min=0.0, E₀=nothing, ΔE=nothing,\n                 modulation=:none, f=0.0, amplitude=1.0,\n                 z_source=h_atm[end]/1e3, t_start=0.0, t_end=0.0)\n\nCreate a time-dependent electron flux distribution with configurable energy spectrum shape and temporal modulation.\n\nReturns an electron flux distribution (in #e⁻/m²/s) such that when integrated over energy (at full modulation), the total energy flux IeE_tot is recovered.\n\nArguments\n\nIeE_tot: total energy flux (W/m²)\nE: energy grid (eV). Vector [nE]\ndE: energy bin widths (eV). Vector [nE]\nμ_center: electron beams average pitch angle cosine. Vector [n_beams]\nBeams: indices of the electron beams with precipitating flux\nBeamWeight: weights of the different beams. Vector [n_beams]\nt: time grid (s). Range or Vector [n_t]\nn_loop: number of loops (for repeated simulations)\nh_atm: altitude grid (m). Vector [n_z]\n\nKeyword Arguments\n\nEnergy spectrum shape\n\nspectrum=:flat: energy spectrum type. Either :flat or :gaussian\nE_min=0.0: minimum energy threshold (eV) - only used for spectrum=:flat\nE₀=nothing: characteristic/center energy (eV) - required for spectrum=:gaussian\nΔE=nothing: energy width (eV) - required for spectrum=:gaussian\n\nTemporal modulation\n\nmodulation=:none: temporal modulation type. One of :none, :sinus, or :square\nf=0.0: modulation frequency (Hz) - used for :sinus and :square\namplitude=1.0: modulation depth. 0 = constant flux, 1 = full on/off modulation. Values between 0 and 1 give partial modulation.\n\nTime-dependent features\n\nz_source: altitude of the precipitation source (km). Default: top of ionosphere\nt_start=0.0: start time for smooth flux onset (s) - only used for modulation=:none\nt_end=0.0: end time for smooth flux onset (s) - only used for modulation=:none\n\nReturns\n\nIe_top: electron number flux (#e⁻/m²/s). Matrix [nbeams, nt, n_E]\n\nPhysics\n\nThe function creates an electron precipitation spectrum with:\n\nEnergy spectrum: Either flat (uniform in #e⁻/m²/s/eV above Emin) or Gaussian (centered at E₀ with width ΔE). Both are normalized so the total energy flux equals `IeEtot`.\nEnergy- and angle-dependent arrival times: Lower energy electrons travel slower, arriving later at the ionosphere top. Similarly, electrons with high pitch-angles travel longer paths. This creates natural dispersion.\nTemporal modulation: The flux can be constant (:none), sinusoidally modulated (:sinus), or square-wave modulated (:square). The amplitude parameter controls the modulation depth.\n\nExamples\n\nFlat spectrum with smooth onset:\n\njulia> E, dE = make_energy_grid(10e3);\n\njulia> θ_lims = 180:-10:0;\n\njulia> μ_center = mu_avg(θ_lims);\n\njulia> BeamWeight = beam_weight(θ_lims);\n\njulia> h_atm = make_altitude_grid(100, 600);\n\njulia> Ie = Ie_top_modulated(1e-2, E, dE, μ_center, 1:2, BeamWeight, 0:0.01:1, 1, h_atm;\n                             spectrum=:flat, E_min=9000.0, t_start=0.0, t_end=0.1);\n\nGaussian spectrum with sinusoidal modulation at 10 Hz:\n\njulia> E, dE = make_energy_grid(10e3);\n\njulia> θ_lims = 180:-10:0;\n\njulia> μ_center = mu_avg(θ_lims);\n\njulia> BeamWeight = beam_weight(θ_lims);\n\njulia> h_atm = make_altitude_grid(100, 600);\n\njulia> Ie = Ie_top_modulated(1e-2, E, dE, μ_center, 1:2, BeamWeight, 0:0.001:0.5, 1, h_atm;\n                             spectrum=:gaussian, E₀=5000.0, ΔE=500.0,\n                             modulation=:sinus, f=10.0, amplitude=1.0);\n\n\n\n\n\nIe_top_modulated(IeE_tot, E, dE, μ_center, Beams, BeamWeight, h_atm;\n                 spectrum=:flat, E_min=0.0, E₀=nothing, ΔE=nothing)\n\nSteady-state version of Ie_top_modulated that does not include time-dependent behavior.\n\nThis overload is designed for steady-state simulations and eliminates the need to specify time-related parameters (t, n_loop, modulation, f, amplitude, z_source, etc.). It internally calls the time-dependent version with minimal time grid (1:1:1) and n_loop=1.\n\nArguments\n\nIeE_tot: total energy flux (W/m²)\nE: energy grid (eV). Vector [nE]\ndE: energy bin widths (eV). Vector [nE]\nμ_center: electron beams average pitch angle cosine. Vector [n_beams]\nBeams: indices of the electron beams with precipitating flux\nBeamWeight: weights of the different beams. Vector [n_beams]\nh_atm: altitude grid (m). Vector [n_z]\n\nKeyword Arguments\n\nspectrum=:flat: energy spectrum type. Either :flat or :gaussian\nE_min=0.0: minimum energy threshold (eV) - only used for spectrum=:flat\nE₀=nothing: characteristic/center energy (eV) - required for spectrum=:gaussian\nΔE=nothing: energy width (eV) - required for spectrum=:gaussian\n\nReturns\n\nIe_top: electron number flux (#e⁻/m²/s). Matrix [nbeams, 1, nE]\n\nExamples\n\njulia> E, dE = make_energy_grid(10e3);\n\njulia> θ_lims = 180:-10:0;\n\njulia> μ_center = mu_avg(θ_lims);\n\njulia> BeamWeight = beam_weight(θ_lims);\n\njulia> h_atm = make_altitude_grid(100, 600);\n\njulia> Ie = Ie_top_modulated(1e-2, E, dE, μ_center, 1:2, BeamWeight, h_atm;\n                             spectrum=:flat, E_min=9000.0);\n\n\n\n\n\n","category":"function"},{"location":"20-api/input_flux/#AURORA.Ie_with_LET-20-api-input_flux","page":"Input Flux","title":"AURORA.Ie_with_LET","text":"Ie_with_LET(IeE_tot, E₀, E, dE, μ_center, BeamWeight, Beams; low_energy_tail=true)\n\nReturn an electron spectra following a Maxwellian distribution with a low energy tail (LET)\n\nThis function is a corrected implementation of Meier/Strickland/Hecht/Christensen JGR 1989 (pages 13541-13552)\n\nArguments\n\nIeE_tot: total energy flux (W/m²)\nE₀: characteristic energy (eV)\nE: energy grid (eV). Vector [nE]\ndE: energy bin sizes(eV). Vector [nE]\nμ_center: electron beams average pitch angle cosine. Vector [n_beams]\nBeamWeight: weights of the different beams. Vector [n_beams]\nBeams: indices of the electron beams with a precipitating flux\nlow_energy_tail=true: control the presence of a low energy tail\n\nReturns:\n\nIe_top: electron number flux (#e⁻/m²/s). Matrix [n_beams, 1, nE]\n\nImportant notes\n\nThis is a corrected version of the equations present in Meier et al. 1989 to match the results presented in Fig. 4 of their paper.\nChanges were made to the factor b:\n\nno inverse\n\nExamples:\n\nCalling the function with flux only in the two first beams (0 to 20°) and an \"isotropic\" pitch-angle distribution.\n\njulia> E, dE = make_energy_grid(100e3);\n\njulia> θ_lims = 180:-10:0;\n\njulia> μ_center = mu_avg(θ_lims);\n\njulia> BeamWeight = beam_weight(180:-10:0);\n\njulia> Ie = AURORA.Ie_with_LET(1e-2, 1e3, E, dE, μ_center, BeamWeight, 1:2);\n\n\nCalling the function with flux only in the three first beams (0 to 30°) and a custom pitch-angle distribution (1/2 of the total flux in the first beam, 1/4 in the second beam and 1/4 in the third beam).\n\njulia> E, dE = make_energy_grid(100e3);\n\njulia> θ_lims = 180:-10:0;\n\njulia> μ_center = mu_avg(θ_lims);\n\njulia> BeamWeight = [2, 1, 1];\n\njulia> Ie = Ie_with_LET(1e-2, 1e3, E, dE, μ_center, BeamWeight, 1:3);\n\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"Pages = [\"95-reference.md\"]","category":"section"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"Pages = [\"95-reference.md\"]","category":"section"},{"location":"95-reference/#AURORA.TransportMatrices","page":"Reference","title":"AURORA.TransportMatrices","text":"TransportMatrices\n\nContainer for the matrices used in the electron transport equations.\n\nFields\n\nA::Vector{Float64}: Loss term matrix (altitude dimension)\nB::Array{Float64, 3}: Scattering term matrix (altitude x angle x angle)\nD::Array{Float64, 2}: Diffusion coefficient matrix (energy x angle)\nQ::Array{Float64, 3}: Source term array (altitude*angle x time x energy)\nDdiffusion::SparseArrays.SparseMatrixCSC{Float64, Int64}: Diffusion operator (altitude x altitude)\n\nThe struct is mutable to allow efficient in-place updates of Q during the energy cascade.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AURORA.TransportMatrices-NTuple{4, Int64}","page":"Reference","title":"AURORA.TransportMatrices","text":"TransportMatrices(n_altitude, n_angle, n_time, n_energy)\n\nConstruct an empty TransportMatrices container with zeros.\n\nArguments\n\nn_altitude::Int: Number of altitude grid points\nn_angle::Int: Number of angle bins\nn_time::Int: Number of time steps\nn_energy::Int: Number of energy bins\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.Crank_Nicolson_optimized!-NTuple{10, Any}","page":"Reference","title":"AURORA.Crank_Nicolson_optimized!","text":"Crank_Nicolson_optimized!(Ie, t, h_atm, μ, v, matrices, iE, Ie_top, I0, cache; first_iteration = false)\n\nOptimized Crank-Nicolson time-stepping scheme using direct nzval modification. This is an in-place version that modifies Ie directly to avoid allocations.\n\nOn first iteration, creates the sparsity pattern and mapping which are stored in cache. On subsequent iterations, only updates the nzval array directly.\n\nMathematical Background\n\nThe time-dependent electron transport equation is:\n\n∂Ie/∂t + μ*v ∂Ie/∂z + A*Ie - ∫B*Ie'dΩ' - D*∇²Ie = Q\n\nThe Crank-Nicolson scheme uses implicit time-stepping with second-order accuracy:\n\n(Ie^(n+1) - Ie^n)/Δt = [RHS^(n+1) + RHS^n] / 2\n\nThis leads to two matrices:\n\nMlhs * Ie^(n+1) = Mrhs * Ie^n + (Q^(n+1) + Q^n)/2\n     ↑                  ↑\nImplicit part      Explicit part\n\nWhere:\n\nMlhs = Ddt + μ*Ddz/2 + A/2 - B/2 - D*Ddiffusion/2\nMrhs = Ddt - μ*Ddz/2 - A/2 + B/2 + D*Ddiffusion/2\n\nBoth matrices have the same block structure as in steady-state:\n\n┌─────────┬─────────┬─────────┐\n│ Block   │ Block   │ Block   │  Each block is n_z × n_z\n│ (1,1)   │ (1,2)   │ (1,3)   │\n├─────────┼─────────┼─────────┤\n│ Block   │ Block   │ Block   │  Off-diagonal: angular scattering\n│ (2,1)   │ (2,2)   │ (2,3)   │\n├─────────┼─────────┼─────────┤\n│ Block   │ Block   │ Block   │  Diagonal: transport + diffusion\n│ (3,1)   │ (3,2)   │ (3,3)   │\n└─────────┴─────────┴─────────┘\n\nArguments\n\nIe: pre-allocated output array [m⁻² s⁻¹], size (nz * nangle × n_t) to store results\nt: time grid [s]\nh_atm: altitude grid [km]\nμ: cosine of pitch angle grid\nv: electron velocity [km/s]\nmatrices::TransportMatrices: container with\nA: electron loss rate [s⁻¹]\nB: scattering matrix [s⁻¹], size (nz × nangle × n_angle)\nD: pitch-angle diffusion coefficient [s⁻¹], size (n_angle,)\nQ: source term [m⁻² s⁻¹] at each time step\nDdiffusion: spatial diffusion matrix (nz × nz)\niE: current energy index\nIe_top: boundary condition at top [m⁻² s⁻¹] at each time step\nI0: initial condition [m⁻² s⁻¹]\ncache: Cache object (must have fields for Mlhs, Mrhs, mappings, KLU, diff matrices)\nfirst_iteration: whether this is the first call\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.Ie_top_from_file-NTuple{4, Any}","page":"Reference","title":"AURORA.Ie_top_from_file","text":"Ie_top_from_file(t, E, μ_center, filename; interpolation=:constant)\n\nLoad a time-dependent electron flux from a .mat file and resample it onto the simulation time grid t.\n\nArguments\n\nt: full simulation time grid (s). Range or Vector [n_t]\nE: energy grid (eV). Vector [n_E]\nμ_center: electron beams average pitch angle cosine. Vector [n_μ]\nfilename: path to the .mat file containing the flux data\n\nKeyword Arguments\n\ninterpolation=: interpolation scheme used to resample the file's time grid onto the simulation time grid. Either:\n:constant (default): each file value is held constant until the next sample.\n:linear: linear interpolation between consecutive file samples.\n\nReturns\n\nIe_top: electron number flux (#e⁻/m²/s). Array [nμ, nt, n_E]\n\nFile format\n\nThe .mat file must contain:\n\nIe_total: flux array of shape [n_μ, n_t_file, n_E]\nt_top: time grid (s) of the file, as a vector [n_t_file]. Optional when n_t_file == 1.\n\nTime grid handling\n\nThe file's time grid (t_top) does not need to match the simulation time grid. Any combination of time step sizes and grid lengths is supported:\n\nDifferent dt: the file is resampled onto the simulation grid via interpolation.\nFile finer than simulation: the flux is point-sampled, which may miss rapid variations.\nFile shorter than simulation: flux is set to zero for times beyond t_top[end].\nFile longer than simulation: the file is simply evaluated up to t[end].\n\nNotes\n\nUpward-going beams (μ_center > 0) are always set to zero.\nThe energy dimension of the file may be larger than length(E); only the first length(E) bins are used. It cannot be smaller.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.Ie_top_modulated-NTuple{7, Any}","page":"Reference","title":"AURORA.Ie_top_modulated","text":"Ie_top_modulated(IeE_tot, E, dE, μ_center, Beams, BeamWeight, h_atm;\n                 spectrum=:flat, E_min=0.0, E₀=nothing, ΔE=nothing)\n\nSteady-state version of Ie_top_modulated that does not include time-dependent behavior.\n\nThis overload is designed for steady-state simulations and eliminates the need to specify time-related parameters (t, n_loop, modulation, f, amplitude, z_source, etc.). It internally calls the time-dependent version with minimal time grid (1:1:1) and n_loop=1.\n\nArguments\n\nIeE_tot: total energy flux (W/m²)\nE: energy grid (eV). Vector [nE]\ndE: energy bin widths (eV). Vector [nE]\nμ_center: electron beams average pitch angle cosine. Vector [n_beams]\nBeams: indices of the electron beams with precipitating flux\nBeamWeight: weights of the different beams. Vector [n_beams]\nh_atm: altitude grid (m). Vector [n_z]\n\nKeyword Arguments\n\nspectrum=:flat: energy spectrum type. Either :flat or :gaussian\nE_min=0.0: minimum energy threshold (eV) - only used for spectrum=:flat\nE₀=nothing: characteristic/center energy (eV) - required for spectrum=:gaussian\nΔE=nothing: energy width (eV) - required for spectrum=:gaussian\n\nReturns\n\nIe_top: electron number flux (#e⁻/m²/s). Matrix [nbeams, 1, nE]\n\nExamples\n\njulia> E, dE = make_energy_grid(10e3);\n\njulia> θ_lims = 180:-10:0;\n\njulia> μ_center = mu_avg(θ_lims);\n\njulia> BeamWeight = beam_weight(θ_lims);\n\njulia> h_atm = make_altitude_grid(100, 600);\n\njulia> Ie = Ie_top_modulated(1e-2, E, dE, μ_center, 1:2, BeamWeight, h_atm;\n                             spectrum=:flat, E_min=9000.0);\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.Ie_top_modulated-NTuple{9, Any}","page":"Reference","title":"AURORA.Ie_top_modulated","text":"Ie_top_modulated(IeE_tot, E, dE, μ_center, Beams, BeamWeight, t, n_loop, h_atm;\n                 spectrum=:flat, E_min=0.0, E₀=nothing, ΔE=nothing,\n                 modulation=:none, f=0.0, amplitude=1.0,\n                 z_source=h_atm[end]/1e3, t_start=0.0, t_end=0.0)\n\nCreate a time-dependent electron flux distribution with configurable energy spectrum shape and temporal modulation.\n\nReturns an electron flux distribution (in #e⁻/m²/s) such that when integrated over energy (at full modulation), the total energy flux IeE_tot is recovered.\n\nArguments\n\nIeE_tot: total energy flux (W/m²)\nE: energy grid (eV). Vector [nE]\ndE: energy bin widths (eV). Vector [nE]\nμ_center: electron beams average pitch angle cosine. Vector [n_beams]\nBeams: indices of the electron beams with precipitating flux\nBeamWeight: weights of the different beams. Vector [n_beams]\nt: time grid (s). Range or Vector [n_t]\nn_loop: number of loops (for repeated simulations)\nh_atm: altitude grid (m). Vector [n_z]\n\nKeyword Arguments\n\nEnergy spectrum shape\n\nspectrum=:flat: energy spectrum type. Either :flat or :gaussian\nE_min=0.0: minimum energy threshold (eV) - only used for spectrum=:flat\nE₀=nothing: characteristic/center energy (eV) - required for spectrum=:gaussian\nΔE=nothing: energy width (eV) - required for spectrum=:gaussian\n\nTemporal modulation\n\nmodulation=:none: temporal modulation type. One of :none, :sinus, or :square\nf=0.0: modulation frequency (Hz) - used for :sinus and :square\namplitude=1.0: modulation depth. 0 = constant flux, 1 = full on/off modulation. Values between 0 and 1 give partial modulation.\n\nTime-dependent features\n\nz_source: altitude of the precipitation source (km). Default: top of ionosphere\nt_start=0.0: start time for smooth flux onset (s) - only used for modulation=:none\nt_end=0.0: end time for smooth flux onset (s) - only used for modulation=:none\n\nReturns\n\nIe_top: electron number flux (#e⁻/m²/s). Matrix [nbeams, nt, n_E]\n\nPhysics\n\nThe function creates an electron precipitation spectrum with:\n\nEnergy spectrum: Either flat (uniform in #e⁻/m²/s/eV above Emin) or Gaussian (centered at E₀ with width ΔE). Both are normalized so the total energy flux equals `IeEtot`.\nEnergy- and angle-dependent arrival times: Lower energy electrons travel slower, arriving later at the ionosphere top. Similarly, electrons with high pitch-angles travel longer paths. This creates natural dispersion.\nTemporal modulation: The flux can be constant (:none), sinusoidally modulated (:sinus), or square-wave modulated (:square). The amplitude parameter controls the modulation depth.\n\nExamples\n\nFlat spectrum with smooth onset:\n\njulia> E, dE = make_energy_grid(10e3);\n\njulia> θ_lims = 180:-10:0;\n\njulia> μ_center = mu_avg(θ_lims);\n\njulia> BeamWeight = beam_weight(θ_lims);\n\njulia> h_atm = make_altitude_grid(100, 600);\n\njulia> Ie = Ie_top_modulated(1e-2, E, dE, μ_center, 1:2, BeamWeight, 0:0.01:1, 1, h_atm;\n                             spectrum=:flat, E_min=9000.0, t_start=0.0, t_end=0.1);\n\nGaussian spectrum with sinusoidal modulation at 10 Hz:\n\njulia> E, dE = make_energy_grid(10e3);\n\njulia> θ_lims = 180:-10:0;\n\njulia> μ_center = mu_avg(θ_lims);\n\njulia> BeamWeight = beam_weight(θ_lims);\n\njulia> h_atm = make_altitude_grid(100, 600);\n\njulia> Ie = Ie_top_modulated(1e-2, E, dE, μ_center, 1:2, BeamWeight, 0:0.001:0.5, 1, h_atm;\n                             spectrum=:gaussian, E₀=5000.0, ΔE=500.0,\n                             modulation=:sinus, f=10.0, amplitude=1.0);\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.Ie_with_LET-NTuple{7, Any}","page":"Reference","title":"AURORA.Ie_with_LET","text":"Ie_with_LET(IeE_tot, E₀, E, dE, μ_center, BeamWeight, Beams; low_energy_tail=true)\n\nReturn an electron spectra following a Maxwellian distribution with a low energy tail (LET)\n\nThis function is a corrected implementation of Meier/Strickland/Hecht/Christensen JGR 1989 (pages 13541-13552)\n\nArguments\n\nIeE_tot: total energy flux (W/m²)\nE₀: characteristic energy (eV)\nE: energy grid (eV). Vector [nE]\ndE: energy bin sizes(eV). Vector [nE]\nμ_center: electron beams average pitch angle cosine. Vector [n_beams]\nBeamWeight: weights of the different beams. Vector [n_beams]\nBeams: indices of the electron beams with a precipitating flux\nlow_energy_tail=true: control the presence of a low energy tail\n\nReturns:\n\nIe_top: electron number flux (#e⁻/m²/s). Matrix [n_beams, 1, nE]\n\nImportant notes\n\nThis is a corrected version of the equations present in Meier et al. 1989 to match the results presented in Fig. 4 of their paper.\nChanges were made to the factor b:\n\nno inverse\n\nExamples:\n\nCalling the function with flux only in the two first beams (0 to 20°) and an \"isotropic\" pitch-angle distribution.\n\njulia> E, dE = make_energy_grid(100e3);\n\njulia> θ_lims = 180:-10:0;\n\njulia> μ_center = mu_avg(θ_lims);\n\njulia> BeamWeight = beam_weight(180:-10:0);\n\njulia> Ie = AURORA.Ie_with_LET(1e-2, 1e3, E, dE, μ_center, BeamWeight, 1:2);\n\n\nCalling the function with flux only in the three first beams (0 to 30°) and a custom pitch-angle distribution (1/2 of the total flux in the first beam, 1/4 in the second beam and 1/4 in the third beam).\n\njulia> E, dE = make_energy_grid(100e3);\n\njulia> θ_lims = 180:-10:0;\n\njulia> μ_center = mu_avg(θ_lims);\n\njulia> BeamWeight = [2, 1, 1];\n\njulia> Ie = Ie_with_LET(1e-2, 1e3, E, dE, μ_center, BeamWeight, 1:3);\n\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA._apply_modulation-NTuple{6, Any}","page":"Reference","title":"AURORA._apply_modulation","text":"_apply_modulation(t_shifted, modulation, f, amplitude, t_start, t_end)\n\nApply temporal modulation to the flux based on the shifted time grid.\n\nArguments\n\nt_shifted: time grid shifted for energy/angle-dependent delays\nmodulation: :none, :sinus, or :square\nf: frequency for sinus/square modulation (Hz)\namplitude: modulation depth (0 = constant, 1 = full on/off)\nt_start, t_end: smooth onset interval (only used for :none)\n\nReturns\n\nVector of modulation factors (0 to 1) for each time step\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA._flat_spectrum-NTuple{4, Any}","page":"Reference","title":"AURORA._flat_spectrum","text":"_flat_spectrum(IeE_tot_eV, E, dE, E_min)\n\nCompute a flat (constant) differential number flux spectrum above Emin, normalized so that the total energy flux equals IeEtot_eV.\n\nReturns a vector of differential number flux per eV (#e⁻/m²/s/eV) for each energy bin. The flux is zero below E_min.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA._gaussian_spectrum-NTuple{5, Any}","page":"Reference","title":"AURORA._gaussian_spectrum","text":"_gaussian_spectrum(IeE_tot_eV, E, dE, E₀, ΔE)\n\nCompute a Gaussian differential number flux spectrum centered at E₀ with width ΔE, normalized so that the total energy flux equals IeEtoteV.\n\nThe Gaussian shape is: Φ(E) ∝ exp(-(E - E₀)² / ΔE²)\n\nReturns a vector of differential number flux per eV (#e⁻/m²/s/eV) for each energy bin.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA._smooth_transition","page":"Reference","title":"AURORA._smooth_transition","text":"_smooth_transition(x, x_start = 0.0, x_end = 1.0)\n\nCreate a smooth transition from 0 to 1 over the interval [x_start, x_end] using a C∞-smooth (infinitely differentiable) function.\n\nReturns 0 for x < x_start\nReturns 1 for x > x_end\nSmoothly transitions from 0 to 1 in between, with all derivatives continuous\n\nArguments\n\nx: The input value at which to evaluate the transition\nx_start: Start of the transition interval (default: 0.0)\nx_end: End of the transition interval (default: 1.0)\n\nReturns\n\nA value between 0 and 1 representing the smooth transition\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.animate_Ie_in_time","page":"Reference","title":"AURORA.animate_Ie_in_time","text":"animate_Ie_in_time(directory_to_process; angles_to_plot=nothing, colorrange=nothing, ...)\n\nPlot a heatmap of Ie over height and energy, and animate it in time. It will load the result files one by one. The animation will be saved as a .mp4 file under the directory_to_process.\n\nExample\n\njulia> directory_to_process = \"Visions2/Alfven_475s\";\n\n# Using defaults for angles and colorrange:\njulia> animate_Ie_in_time(directory_to_process)\n\n# Or with custom angles and colorrange:\njulia> angles_to_plot = [(180, 170)  (170, 150)  (150, 120)  (120, 100)  (100, 90);   # DOWN\n                         (0, 10)     (10, 30)    (30, 60)    (60, 80)    (80, 90)];   # UP\njulia> animate_Ie_in_time(directory_to_process; angles_to_plot, colorrange=(1e5, 1e9), plot_Ietop=true)\n\n# Using nothing for empty panels:\njulia> angles_to_plot = [(180, 90)  nothing;\n                         (0, 45)    (45, 90)];\njulia> animate_Ie_in_time(directory_to_process; angles_to_plot)\n\nThe angles_to_plot is a matrix of tuples, where each tuple defines a pitch-angle range from 0° to 180° (where 180° is field-aligned down and 0° is field-aligned up). A panel will be created for each matrix element at the corresponding row/column position. Angles > 90° are labeled as \"DOWN\", angles < 90° as \"UP\". Use nothing for empty panels.\n\nThe limits of angles_to_plot need to match existing limits of the beams used in the simulation. E.g. if θ_lims = 180:-10:0 was used in the simulation, (150, 120) will be fine as 150° and 120° exist as limits, but (155, 120) will not as 155° does not exist as a limit.\n\nArguments\n\ndirectory_to_process: directory containing the simulation results (absolute or relative path).\n\nKeyword Arguments\n\nangles_to_plot = nothing: limits of the angles to plot as a matrix of tuples with angles                             in range 0-180°. Use nothing for empty panels. If the whole                             argument is nothing, uses the θ_lims grid from the simulation                             with down-flux on the first row and up-flux on the second row.\ncolorrange = nothing: limits for the colormap/colorbar as a tuple (min, max). If nothing,                         automatically computed as (maxvalue / 1e4, maxvalue) spanning                         4 orders of magnitude.\nsave_to_file = true: if true, saves the animation to a .mp4 file in the data directory.\nplot_Ietop = false: if true, also plots the precipitating Ie at the top of the                       ionosphere by loading it from the file Ie_top.mat.\nIetop_angle_cone = [170, 180]: angle cone (in degrees) for the precipitating Ie                       to plot.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.beam_weight-Tuple{Any}","page":"Reference","title":"AURORA.beam_weight","text":"beam_weight(θ_lims)\n\nReturn the beam weights of the pitch-angle beams delimited by θ_lims.\n\nCalling\n\nBeamW = beam_weight(θ_lims)\n\nInputs\n\nθ_lims : pitch-angle limits of all the beams, range or vector [n_beams + 1]\n\nOutputs\n\nBeamW : solid angle of each pitch-angle beams (ster), vector [n_beams]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.calculate_cascading_N2","page":"Reference","title":"AURORA.calculate_cascading_N2","text":"calculate_cascading_N2(E_grid, dE, lorentzian_width)\n\nCalculate cascading transfer matrices for N₂ ionization.\n\nArguments\n\nE_grid: Energy grid for electrons (eV)\ndE: Energy grid step size (eV)\nlorentzian_width: Width of the Lorentzian distribution (eV)\n\nReturns\n\nQ_transfer_matrix: Transfer matrix [nenergies, nenergies, n_thresholds]\n\nReference\n\nEquation from Itikawa 1986 J. Phys. Chem. Ref. Data\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.calculate_cascading_N2_quadgk","page":"Reference","title":"AURORA.calculate_cascading_N2_quadgk","text":"calculate_cascading_N2_quadgk(E_grid, dE, lorentzian_width)\n\nCalculate cascading transfer matrices for N₂ ionization using nested quadgk integrals.\n\nThis is an alternative implementation to calculate_cascading_N2 that uses two nested one-dimensional integrals instead of a hypercube transformation. The integration is performed over the physical domain directly:\n\nOuter integral: over degraded electron energy E_degraded\nInner integral: over primary electron energy E_primary\n\nArguments\n\nE_grid: Energy grid for electrons (eV)\ndE: Energy grid step size (eV)\nlorentzian_width: Width of the Lorentzian distribution (eV)\n\nReturns\n\nQ_transfer_matrix: Transfer matrix [nenergies, nenergies, n_thresholds]\nE_grid: Energy grid (returned for consistency)\nionization_thresholds: Array of ionization threshold energies\n\nReference\n\nEquation from Itikawa 1986 J. Phys. Chem. Ref. Data\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.calculate_cascading_O-Tuple{Any, Any}","page":"Reference","title":"AURORA.calculate_cascading_O","text":"calculate_cascading_O(E_grid, dE)\n\nCalculate cascading transfer matrices for atomic O ionization.\n\nArguments\n\nE_grid: Energy grid for electrons (eV)\ndE: Energy grid step size (eV)\n\nReturns\n\nQ_transfer_matrix: Transfer matrix [nenergies, nenergies, n_thresholds]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.calculate_cascading_O2","page":"Reference","title":"AURORA.calculate_cascading_O2","text":"calculate_cascading_O2(E_grid, dE, lorentzian_width)\n\nCalculate cascading transfer matrices for O₂ ionization.\n\nArguments\n\nE_grid: Energy grid for electrons (eV)\ndE: Energy grid step size (eV)\nlorentzian_width: Width of the Lorentzian distribution (eV)\n\nReturns\n\nQ_transfer_matrix: Transfer matrix [nenergies, nenergies, n_thresholds]\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.calculate_cascading_O2_quadgk","page":"Reference","title":"AURORA.calculate_cascading_O2_quadgk","text":"calculate_cascading_O2_quadgk(E_grid, dE, lorentzian_width)\n\nCalculate cascading transfer matrices for O₂ ionization using nested quadgk integrals.\n\nThis is an alternative implementation to calculate_cascading_O2 that uses two nested one-dimensional integrals instead of a hypercube transformation. The integration is performed over the physical domain directly:\n\nOuter integral: over degraded electron energy E_degraded\nInner integral: over primary electron energy E_primary\n\nArguments\n\nE_grid: Energy grid for electrons (eV)\ndE: Energy grid step size (eV)\nlorentzian_width: Width of the Lorentzian distribution (eV)\n\nReturns\n\nQ_transfer_matrix: Transfer matrix [nenergies, nenergies, n_thresholds]\nE_grid: Energy grid (returned for consistency)\nionization_thresholds: Array of ionization threshold energies\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.calculate_cascading_O_quadgk-Tuple{Any, Any}","page":"Reference","title":"AURORA.calculate_cascading_O_quadgk","text":"calculate_cascading_O_quadgk(E_grid, dE)\n\nCalculate cascading transfer matrices for atomic O ionization using nested quadgk integrals.\n\nThis is an alternative implementation to calculate_cascading_O that uses two nested one-dimensional integrals instead of a hypercube transformation. The integration is performed over the physical domain directly:\n\nOuter integral: over degraded electron energy E_degraded\nInner integral: over primary electron energy E_primary\n\nArguments\n\nE_grid: Energy grid for electrons (eV)\ndE: Energy grid step size (eV)\n\nReturns\n\nQ_transfer_matrix: Transfer matrix [nenergies, nenergies, n_thresholds]\nE_grid: Energy grid (returned for consistency)\nionization_thresholds: Array of ionization threshold energies\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.calculate_density_from_Ie!-NTuple{7, Any}","page":"Reference","title":"AURORA.calculate_density_from_Ie!","text":"calculate_density_from_Ie!(h_atm, t_run, μ_lims, E_middle_bin, v, Ie, n_e)\n\nThis function converts a particle flux Ie (#e⁻/m²/s) into a number density n_e (#e⁻/m³).\n\nThe particle flux Ie is defined along a magnetic field line and over an (Energy, pitch_angle)-grid. The number density n_e calculated is given along a magnetic field line and over an energy grid. That way, we have the density of electrons with a certain energy at a specific altitude and time.\n\nCalling\n\ncalculate_density_from_Ie!(h_atm, t_run, μ_lims, E_middle_bin, v, Ie, n_e)\n\nInputs\n\nh_atm: altitude (m), vector [nz]\nt_run: time (s), vector [nt]\nμ_lims: cosine of the pitch angle limits of the e- beams, vector [n_beam + 1]\nE_middle_bin: middle energy of the energy bins (eV), vector [nE]\nv: velocity corresponding to the E_middle_bin (m/s), vector [nE]\nIe: electron flux (#e⁻/m²/s), 3D array [n_beam * nz, nt, nE]\nn_e: electron density (#e⁻/m³), empty 3D array [nz, nt, nE]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.calculate_e_transport","page":"Reference","title":"AURORA.calculate_e_transport","text":"calculate_e_transport(altitude_lims, θ_lims, E_max, B_angle_to_zenith, t_total, dt,\n    msis_file, iri_file, savedir, INPUT_OPTIONS, CFL_number = 64;\n    n_loop = nothing, max_memory_gb = 8, save_input_flux = true)\n\nRun a time-dependent electron transport simulation and save the results to savedir.\n\nArguments\n\naltitude_lims: altitude range of the simulation (km). Tuple or Vector\nθ_lims: pitch-angle beam limits (degrees). Range or Vector [n_beams + 1]\nE_max: maximum energy of the simulation (eV)\nB_angle_to_zenith: angle between the magnetic field and the zenith (degrees)\nt_total: total simulation time (s)\ndt: output time step (s)\nmsis_file: path to the MSIS neutral atmosphere file\niri_file: path to the IRI ionosphere file\nsavedir: path to the directory where results will be saved\nINPUT_OPTIONS: NamedTuple describing the incoming electron flux source\nCFL_number: CFL multiplier used to sub-sample the time grid (default: 64)\n\nKeyword Arguments\n\nn_loop: number of loops to split the time grid into. Computed automatically from max_memory_gb if not provided\nmax_memory_gb: memory budget used to compute n_loop automatically\nsave_input_flux: if true, save the computed top-boundary flux Ie_top to Ie_incoming.mat in savedir before the simulation starts\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.calculate_e_transport_steady_state-NTuple{8, Any}","page":"Reference","title":"AURORA.calculate_e_transport_steady_state","text":"calculate_e_transport_steady_state(altitude_lims, θ_lims, E_max, B_angle_to_zenith,\n    msis_file, iri_file, savedir, INPUT_OPTIONS; save_input_flux = true)\n\nRun a steady-state electron transport simulation and save the results to savedir.\n\nArguments\n\naltitude_lims: altitude range of the simulation (km). Tuple or Vector\nθ_lims: pitch-angle beam limits (degrees). Range or Vector [n_beams + 1]\nE_max: maximum energy of the simulation (eV)\nB_angle_to_zenith: angle between the magnetic field and the zenith (degrees)\nmsis_file: path to the MSIS neutral atmosphere file\niri_file: path to the IRI ionosphere file\nsavedir: path to the directory where results will be saved\nINPUT_OPTIONS: NamedTuple describing the incoming electron flux source\n\nKeyword Arguments\n\nsave_input_flux: if true, save the computed top-boundary flux Ie_top to Ie_incoming.mat in savedir before the simulation starts\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.calculate_heating_rate-NTuple{6, Any}","page":"Reference","title":"AURORA.calculate_heating_rate","text":"calculate_heating_rate(h_atm, t, Ie_ztE_omni, E, ne, Te)\n\nCalculate the heating rate of thermal electrons by superthermal electrons through Coulomb collisions. The heating rate is the rate at which energy is transferred from superthermal electrons to thermal electrons.\n\nCalling\n\nheating_rate = calculate_heating_rate(h_atm, t, Ie_ztE_omni, E, ne, Te)\n\nInputs\n\nh_atm: altitude (m). Vector [n_z]\nt: time (s). Vector [n_t]\nIe_ztE_omni: omnidirectional electron flux (#e⁻/m²/s). 3D array [n_z, n_t, n_E]\nE: energy (eV). Vector [n_E]\nne: thermal electron density (m⁻³). Vector [n_z]\nTe: thermal electron temperature (K). Vector [n_z]\n\nOutput\n\nheating_rate: heating rate (eV/m³/s). 2D array [n_z, n_t]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.calculate_iri_data-Tuple{}","page":"Reference","title":"AURORA.calculate_iri_data","text":"calculate_iri_data(; year=2018, month=12, day=7, hour=11, minute=15,\n                    lat=76, lon=5, height=85:1:700)\n\nCalculate IRI-2016 ionospheric model data using Python interface.\n\nThis function calls the Python iri2016 package to compute ionospheric parameters including electron density, temperatures, and ion composition profiles. The data is returned as a matrix with a header row containing column names.\n\nKeyword Arguments\n\nyear::Int=2018: Year (defaults to Visions2 launch conditions)\nmonth::Int=12: Month (1-12)\nday::Int=7: Day of month (1-31)\nhour::Int=11: Hour in Universal Time (0-23)\nminute::Int=15: Minute (0-59)\nlat::Real=76: Geographic latitude in degrees North\nlon::Real=5: Geographic longitude in degrees East\nheight::AbstractRange=85:1:700: Altitude range in km\n\nReturns\n\nTuple{Matrix, NamedTuple}:\nMatrix with header row and IRI data (21 columns: height + 20 parameters)\nNamedTuple with input parameters\n\nData Columns\n\nThe returned matrix contains the following columns:\n\nheight(km): Altitude\nne(m⁻³): Electron density\nTn(K): Neutral temperature\nTi(K): Ion temperature\nTe(K): Electron temperature\n\n6-12. nO⁺, nH⁺, nHe⁺, nO2⁺, nNO⁺, nCI, nN⁺: Ion densities (m⁻³) 13-18. NmF2, hmF2, NmF1, hmF1, NmE, hmE: Peak densities and heights\n\nTEC: Total Electron Content\nEqVertIonDrift: Equatorial vertical ion drift\nfoF2: F2 critical frequency\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.calculate_msis_data-Tuple{}","page":"Reference","title":"AURORA.calculate_msis_data","text":"calculate_msis_data(; year=2018, month=12, day=7, hour=11, minute=15,\n                     lat=76, lon=5, height=85:1:700)\n\nCalculate NRLMSIS 2.1 atmospheric model data using Python interface.\n\nThis function calls the Python pymsis package to compute neutral atmosphere parameters including densities of various species (N₂, O₂, O, He, H, Ar, N, NO) and temperature profiles. The data is returned as a matrix with a header row containing column names.\n\nKeyword Arguments\n\nyear::Int=2018: Year (defaults to Visions2 launch conditions)\nmonth::Int=12: Month (1-12)\nday::Int=7: Day of month (1-31)\nhour::Int=11: Hour in Universal Time (0-23)\nminute::Int=15: Minute (0-59)\nlat::Real=76: Geographic latitude in degrees North\nlon::Real=5: Geographic longitude in degrees East\nheight::AbstractRange=85:1:700: Altitude range in km\n\nReturns\n\nTuple{Matrix, NamedTuple}:\nMatrix with header row and MSIS data (12 columns: height + 11 parameters)\nNamedTuple with input parameters\n\nData Columns\n\nThe returned matrix contains the following columns:\n\nheight(km): Altitude\nair(kg/m³): Total mass density\nN₂(m⁻³): Molecular nitrogen density\nO₂(m⁻³): Molecular oxygen density\nO(m⁻³): Atomic oxygen density\nHe(m⁻³): Helium density\nH(m⁻³): Atomic hydrogen density\nAr(m⁻³): Argon density\nN(m⁻³): Atomic nitrogen density\nanomalousO(m⁻³): Anomalous oxygen density\nNO(m⁻³): Nitric oxide density\nT(K): Temperature\n\nNotes\n\nThis function automatically downloads the SW-All.csv file (space weather data) if not already present in the pymsis package directory\nThe geomagnetic activity parameter is set to -1 (use observational data)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.calculate_n_loop-NTuple{4, Any}","page":"Reference","title":"AURORA.calculate_n_loop","text":"calculate_n_loop(t, n_z, n_μ, n_E; max_memory_gb=8, verbose=true)\n\nCalculate the optimal number of loops (n_loop) for the electron transport simulation based on memory constraints.\n\nThis function determines how many time-slices the simulation should be divided into to stay within the specified memory limit.\n\nArguments\n\nt: Time array after CFL refinement (from CFL_criteria)\nn_z::Int: Number of altitude grid points\nn_μ::Int: Number of pitch-angle beams\nn_E::Int: Number of energy grid points\n\nKeyword Arguments\n\nmax_memory_gb: Maximum memory to use (GB). Defaults to 8 GB.\nverbose::Bool=true: If true, print some information about the calculation\n\nReturns\n\nn_loop::Int: Recommended number of loops\n\nExample\n\nt, CFL_factor = CFL_criteria(1.0, 0.001, h_atm, v_of_E(10000))\nn_loop = calculate_n_loop(t, length(h_atm), n_μ, n_E)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.calculate_scattered_flux!-NTuple{4, Any}","page":"Reference","title":"AURORA.calculate_scattered_flux!","text":"calculate_scattered_flux!(result, B2B_inelastic, n, Ie_slice)\n\nCalculate the flux of electrons after pitch-angle scattering by inelastic collisions.\n\nPhysics\n\nThe scattered flux at each altitude and angle is computed as:     result[z, μ₁, t] = Σ_μ₂ n(z) x P(μ₁←μ₂) x Ie[z, μ₂, t]\n\nwhere:\n\nn(z) is the neutral density at altitude z\nP(μ₁←μ₂) is the probability of scattering from pitch angle μ₂ to μ₁ (from B2B_inelastic)\nIe[z, μ₂, t] is the incident electron flux before scattering\n\nImplementation\n\nThis exploits the block-diagonal structure of the full scattering matrix to avoid storing and accessing a large sparse matrix. Instead, it computes the multiplication directly from the small scattering probability matrix and density profile.\n\nArguments\n\nresult: Output array (nz x nμ, n_t) - scattered electron flux\nB2B_inelastic: Scattering probability matrix (nμ, nμ) - pitch angle redistribution\nn: Neutral density profile (n_z,) - altitude-dependent density [m⁻³]\nIe_slice: Incident electron flux at the current energy (nz x nμ, n_t) - flux before scattering\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.calculate_scattering_matrices","page":"Reference","title":"AURORA.calculate_scattering_matrices","text":"calculate_scattering_matrices(θ_lims, n_direction = 720)\n\nCalculate the scattering matrices for given pitch-angle limits θ_lims of the electron beams. Uses 720 directions by default for the start angle and the scattering angles, equivalent to (1/4)° steps.\n\nCalling\n\nPmu2mup, theta2beamW, BeamWeight_relative, θ₁ =  calculate_scattering_matrices(θ_lims, n_direction)\n\nInputs\n\nθ_lims: pitch-angle limits of the electron beams (e.g. 180:-10:0), where 180°   corresponds to field aligned down, and 0° field aligned up.\nn_direction: number of directions or sub-beams to use for the discretized calculations   of the scattering matrices. Defaults to 720 when left empty.\n\nOutputs\n\nPmu2mup: probabilities for scattering in 3D from beam to beam. Matrix [n_direction x * n_direction x n_beam]\ntheta2beamW: weight of each sub-beam within each beam. Matrix [n_beam x n_direction]\nBeamWeight_relative: relative weight of each sub-beam within each beam. It is the same   as theta2beamW but normalized so that summing along the sub-beams gives 1 for each beam.   Matrix [n_beam x n_direction]\nθ₁: scattering angles used in the calculations. Vector [n_direction]\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.calculate_scattering_matrices_legacy","page":"Reference","title":"AURORA.calculate_scattering_matrices_legacy","text":"calculate_scattering_matrices_legacy(θ_lims, n_direction=720)\n\nCalculate the scattering matrices for given pitch-angle limits θ_lims of the electron beams.\n\nCalling\n\nPmu2mup, theta2beamW, BeamWeight_relative, θ₁ =  calculate_scattering_matrices_legacy(θ_lims, n_direction)\n\nInputs\n\nθ_lims: pitch-angle limits of the electron beams (e.g. 180:-10:0), where 180°   corresponds to field aligned down, and 0° field aligned up.\nn_direction: number of directions or sub-beams to use for the discretized calculations   of the scattering matrices. Defaults to 720 when left empty.\n\nOutputs\n\nPmu2mup: probabilities for scattering in 3D from beam to beam. Matrix [n_direction x   2 * n_direction x n_beam]\ntheta2beamW: weight of each sub-beam within each beam. Matrix [n_beam x   n_direction]\nBeamWeight_relative: relative weight of each sub-beam within each beam. It is the same   as theta2beamW but normalized so that summing along the sub-beams gives 1 for each beam.   Matrix [n_beam x n_direction]\nθ₁: scattering angles used in the calculations. Vector [n_direction]\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.calculate_volume_excitation-NTuple{5, Any}","page":"Reference","title":"AURORA.calculate_volume_excitation","text":"calculate_volume_excitation(h_atm, t, Ie_ztE_omni, σ, n)\n\nCalculate the volume-excitation-rate for an excitation of interest, produced by the electron flux Ie_ztE_omni that is summed over the beams (omnidirectional).\n\nThe excitation of interest is chosen through the cross-section σ given to the function. Note that the neutral density n should match the excitation of interest (e.g. use nN2 when calculating the volume-excitation-rate of the 4278Å optical emission).\n\nCalling\n\nQ = calculate_volume_excitation(h_atm, t, Ie_ztE, σ, n)`\n\nInputs\n\nh_atm: altitude (m). Vector [n_z]\nt: time (s). Vector [n_t]\nIe_ztE_omni: omnidirectional electron flux (#e⁻/m²/s). 3D array [n_z, n_t, n_E]\nσ: excitation cross-section (m⁻²). Vector [n_E]\nn: density of exciteable atmospheric specie (m⁻³). Vector [n_z]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.create_crank_nicolson_nzval_mappings-NTuple{4, Any}","page":"Reference","title":"AURORA.create_crank_nicolson_nzval_mappings","text":"create_crank_nicolson_nzval_mappings(Mlhs, Mrhs, n_z, n_angle)\n\nCreate mappings for both Mlhs and Mrhs matrices. Returns (mappinglhs, mappingrhs).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.create_crank_nicolson_sparsity_patterns-NTuple{5, Any}","page":"Reference","title":"AURORA.create_crank_nicolson_sparsity_patterns","text":"create_crank_nicolson_sparsity_patterns(n_z, n_angle, μ, D, Ddiffusion)\n\nCreate the sparsity patterns for both Mlhs and Mrhs matrices. The structure is the same for both, only values differ.\n\nReturns (Mlhs, Mrhs) with correct sparsity structure.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.create_steady_state_nzval_mapping-Tuple{Any, Any, Any}","page":"Reference","title":"AURORA.create_steady_state_nzval_mapping","text":"create_steady_state_nzval_mapping(Mlhs, n_z, n_angle)\n\nCreate a mapping from matrix block positions to nzval indices for efficient in-place updates.\n\nJulia uses the CSC (Compressed Sparse Column) format for sparse matrices, with three arrays:\n\ncolptr: Column pointers (which rows are in each column)\nrowval: Row indices of non-zero values\nnzval: The actual non-zero values\n\nThis function computes a mapping that tells us which index in nzval corresponds to each matrix element we want to update. With this mapping, we can directly modify nzval in place, avoiding expensive matrix reconstruction.\n\nReturns a structured mapping where mapping[i1, i2][(:type, position)] gives the nzval index for the specified matrix element in block (i1, i2).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.create_steady_state_sparsity_pattern-NTuple{5, Any}","page":"Reference","title":"AURORA.create_steady_state_sparsity_pattern","text":"create_steady_state_sparsity_pattern(n_z, n_angle, μ, D, Ddiffusion)\n\nCreate the sparsity pattern (structure) of the steady-state LHS matrix once. This can be reused by only modifying nzval values, avoiding allocations.\n\nReturns the sparse matrix with the correct structure.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.downsampling_fluxes-Tuple{Any, Any}","page":"Reference","title":"AURORA.downsampling_fluxes","text":"downsampling_fluxes(directory_to_process, downsampling_factor)\n\nThis function extracts Ie from the simulation results in directory_to_process and downsample it in time. For example: if Ie is given with a time step of 1ms and we use a downsampling_factor of 10, this function will extract the values of Ie with a time step of 10ms. It will then save the results in a new subfolder calleddownsampled_10x, inside the directory_to_process.\n\nCalling\n\ndownsampling_fluxes(directory_to_process, downsampling_factor)\n\nInputs\n\ndirectory_to_process: absolute or relative path to the simulation directory to process.\ndownsampling_factor: downsampling factor for the time\n\nOutputs\n\nThe downsampled electron fluxes Ie will be saved in a subfolder inside the directory_to_process.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.excitation_4278-Tuple{Any}","page":"Reference","title":"AURORA.excitation_4278","text":"excitation_4278(E)\n\nReturns the electron-impact excitation cross-section for 4278Å from N2 ions.\n\nBest fit to experiments (Tima Sergienko, personal communication).\n\nCalling\n\nσ = excitation_4278(E)\n\nInput\n\nE: incoming electron energy (eV)\n\nOutput\n\nσ: emission cross-section (m²)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.excitation_6730_N2-Tuple{Any}","page":"Reference","title":"AURORA.excitation_6730_N2","text":"excitation_6730_N2(E)\n\nReturns the electron-impact excitation cross-section for 6730Å bands from N2 for transitions 4-1 and 5-2.\n\nDigitised and extrapolated from Lanchester et al. (2009), p. 2545. https://doi.org/10.5194/angeo-27-2881-2009\n\n% parent       N2 % products     0    (emission) % threshold    7.3532   (???) % units        eV\n\nCalling\n\nσ = excitation_6730_N2(E)\n\nInput\n\nE: incoming electron energy (eV)\n\nOutput\n\nσ: emission cross-section (m²)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.excitation_7774_O-Tuple{Any}","page":"Reference","title":"AURORA.excitation_7774_O","text":"excitation_7774_O(E)\n\nReturns the electron-impact excitation cross-section for 7774Å from O. Produced by the transition     groud-state –(different pathways)–> OI 3p 5P –(prompt emission of 7774Å)–> OI 3s 5S\n\nDigitized and extrapolated from Julienne and Davis (1976), p. 1397. https://doi.org/10.1029/JA081i007p01397\n\n% \ttyped in by Mina Ashrafi July 2008 % parent       O % products     0    (emission) % threshold    10.74   (Itikawa Corrected:BG-20191016) % units        eV\n\nCalling\n\nσ = excitation_7774_O(E)\n\nInput\n\nE: incoming electron energy (eV)\n\nOutput\n\nσ: emission cross-section (m²)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.excitation_7774_O2-Tuple{Any}","page":"Reference","title":"AURORA.excitation_7774_O2","text":"excitation_7774_O2(E)\n\nReturns the electron-impact excitation cross-section for 7774Å from O2. Produced by the dissociative ionization/excitation of     O2 –(different pathways)–> OI 3p 5P –(prompt emission of 7774Å)–> OI 3s 5S\n\nFrom Erdman and Zipf (1987), p. 4540. https://doi.org/10.1063/1.453696\n\n% \ttyped in by Mykola/Nickolay Ivshenko August 2006 % parent       O2 % products     0    (emission) % threshold    15.9   (???) Seems OK, 10.74 + 5.15 (O2-bond-energy) % units        eV\n\nCalling\n\nσ = excitation_7774_O2(E)\n\nInput\n\nE: incoming electron energy (eV)\n\nOutput\n\nσ: emission cross-section (m²)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.excitation_8446_O-Tuple{Any}","page":"Reference","title":"AURORA.excitation_8446_O","text":"excitation_8446_O(E)\n\nReturns the electron-impact excitation cross-section for 8446Å from O. Produced by the transition     ground-state –(different pathways)–> OI 3p 3P –(prompt emission of 8446Å)–> ??\n\nFrom Itikawa and Ichimura (1990). https://doi.org/10.1063/1.555857\n\n% parent       O % products     0    (emission) % threshold    10.99   (Itikawa) Confirmed/BG-20191016 % units        eV\n\nCalling\n\nσ = excitation_8446_O(E)\n\nInput\n\nE: incoming electron energy (eV)\n\nOutput\n\nσ: emission cross-section (m²)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.excitation_8446_O2-Tuple{Any}","page":"Reference","title":"AURORA.excitation_8446_O2","text":"excitation_8446_O2(E)\n\nReturns the electron-impact excitation cross-section for 8446Å from O2. Produced by the dissociative ionization/excitation of     O2 –(different pathways)–> OI 3p 3P –(prompt emission of 8446Å)–> ??\n\nFrom Schulman et al. (1985). Digitised from fig.7 by Daniel Whiter in March 2009. Value in paper is 2 +/- 15% @ 100eV. https://doi.org/10.1103/PhysRevA.32.2100\n\n% parent       O2 % products     0    (emission) % threshold    15.9   (???) - seems low, dissociation energy of O2 %                             is 5.16 eV and the energy-level of %                             O(3p3P) is 10.99 eV, so threshold has %                             to  be 16.15 eV /BG 20180529\n\nCalling\n\nσ = excitation_8446_O2(E)\n\nInput\n\nE: incoming electron energy (eV)\n\nOutput\n\nσ: emission cross-section (m²)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.excitation_O1D-Tuple{Any}","page":"Reference","title":"AURORA.excitation_O1D","text":"excitation_O1D(E)\n\nReturns the electron-impact excitation cross-section for O1D (will emit 6300Å, not prompt).\n\nFrom Itikawa and Ichimura (1990). https://doi.org/10.1063/1.555857\n\nCalling\n\nσ = excitation_O1D(E)\n\nInput\n\nE: incoming electron energy (eV)\n\nOutput\n\nσ: emission cross-section (m²)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.excitation_O1S-Tuple{Any}","page":"Reference","title":"AURORA.excitation_O1S","text":"excitation_O1S(E)\n\nReturns the electron-impact excitation cross-section for O1S (will emit 5577Å, not prompt).\n\nFrom Itikawa and Ichimura (1990). https://doi.org/10.1063/1.555857\n\nCalling\n\nσ = excitation_O1S(E)\n\nInput\n\nE: incoming electron energy (eV)\n\nOutput\n\nσ: emission cross-section (m²)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.find_Ietop_file-Tuple{Any}","page":"Reference","title":"AURORA.find_Ietop_file","text":"find_Ietop_file(path_to_directory)\n\nLook for Ie_incoming file present in the directory given by path_to_directory. If several files are starting with the name \"Ie_incoming\", return an error. If only one file is found, return a string with the path to that file.\n\nCalling\n\nIetop_file = find_Ietop_file(path_to_directory)\n\nInputs\n\npath_to_directory: path to a directory\n\nReturns\n\nIetop_file: path to the Ie_incoming file, in the form \"pathtodirectory/Ieincoming*.mat\"\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.find_cascading_file-Tuple{Any, Any}","page":"Reference","title":"AURORA.find_cascading_file","text":"find_cascading_file(E_grid, species_dir)\n\nSearch for a pre-computed cascading spectra file with matching energy grid.\n\nArguments\n\nE_grid: Energy grid to match\nspecies_dir: Directory containing cascading data files for the species\n\nReturns\n\n(file_found, filepath): Tuple of boolean and filepath string\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.find_iri_file-Tuple{}","page":"Reference","title":"AURORA.find_iri_file","text":"find_iri_file(; year=2018, month=12, day=7, hour=11, minute=15,\n                lat=76, lon=5, height=85:1:700)\n\nFind or create an IRI model data file for the specified conditions.\n\nIt first searches for an existing IRI file matching the given parameters. If no matching file is found, it calculates new IRI data using the Python iri2016 package and saves it to a file. The iri2016 package will compile and run some fortran code under the hood.\n\nKeyword Arguments\n\nyear::Int=2018: Year\nmonth::Int=12: Month (1-12)\nday::Int=7: Day of month (1-31)\nhour::Int=11: Hour in Universal Time (0-23)\nminute::Int=15: Minute (0-59)\nlat::Real=76: Geographic latitude in degrees North\nlon::Real=5: Geographic longitude in degrees East\nheight::AbstractRange=85:1:700: Altitude range in km\n\nReturns\n\nString: Full path to the IRI data file\n\nNotes\n\nDefault parameters correspond to the VISIONS-2 rocket launch conditions\nFiles are stored in internal_data/data_electron/ directory\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.find_msis_file-Tuple{}","page":"Reference","title":"AURORA.find_msis_file","text":"find_msis_file(; year=2018, month=12, day=7, hour=11, minute=15,\n                lat=76, lon=5, height=85:1:700)\n\nFind or create a MSIS model data file for the specified conditions.\n\nIt first searches for an existing MSIS file matching the given parameters. If no matching file is found, it calculates new MSIS data using the Python pymsis package and saves it to a file. The pymsis package will download, compile and run some fortran code under the hood.\n\nKeyword Arguments\n\nyear::Int=2018: Year\nmonth::Int=12: Month (1-12)\nday::Int=7: Day of month (1-31)\nhour::Int=11: Hour in Universal Time (0-23)\nminute::Int=15: Minute (0-59)\nlat::Real=76: Geographic latitude in degrees North\nlon::Real=5: Geographic longitude in degrees East\nheight::AbstractRange=85:1:700: Altitude range in km\n\nReturns\n\nString: Full path to the MSIS data file\n\nNotes\n\nDefault parameters correspond to the VISIONS-2 rocket launch conditions\nFiles are stored in internal_data/data_neutrals/ directory\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.find_scattering_matrices","page":"Reference","title":"AURORA.find_scattering_matrices","text":"find_scattering_matrices(θ_lims, n_direction=720)\n\nLook for scattering matrices that match the pitch-angle limits θ_lims and the number of direction/sub-beams n_direction. If a file is found, the scattering matrices are directly loaded. Otherwise, they are calculated and saved to a file.\n\nCalling\n\nPmu2mup, theta2beamW, BeamWeight_relative, θ₁ =  find_scattering_matrices(θ_lims, n_direction)\n\nInputs\n\nθ_lims: pitch-angle limits of the electron beams (e.g. 180:-10:0), where 180°   corresponds to field aligned down, and 0° field aligned up.\nn_direction: number of directions or sub-beams to use for the discretized calculations   of the scattering matrices. Defaults to 720 when left empty.\n\nOutputs\n\nPmu2mup: probabilities for scattering in 3D from beam to beam. Matrix [n_direction x   n_direction]\ntheta2beamW: weight of each sub-beam within each beam. Matrix [n_beam x   n_direction]\nBeamWeight_relative: relative weight of each sub-beam within each beam. It is the same   as theta2beamW but normalized so that summing along the sub-beams gives 1 for each beam.   Matrix [n_beam x n_direction]\nθ₁: scattering angles used in the calculations. Vector [n_direction]\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.get_cross_section-Tuple{Any, Any, Any}","page":"Reference","title":"AURORA.get_cross_section","text":"get_cross_section(species_name, E, dE)\n\nCalculate the cross-section for a given species and their different energy states.\n\nCalling\n\nσ_N2 = get_cross_section(\"N2\", E, dE)\n\nInputs\n\nspecies_name: name of the species. String\nE: energy grid (eV). Vector [nE]\ndE: energy grid step size (eV). Vector [nE]\n\nOutputs\n\nσ_species: A matrix of cross-section values for each energy state, for the defined species\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.initialize_transport_matrices-NTuple{6, Any}","page":"Reference","title":"AURORA.initialize_transport_matrices","text":"initialize_transport_matrices(h_atm, μ_center, t, E, dE, θ_lims)\n\nCreate a TransportMatrices container initialized with zeros for A, B, D, Q and Ddiffusion.\n\nArguments\n\nh_atm: Altitude grid\nμ_center: Cosine of angle centers\nt: Time grid\nE, dE: Energy grid and bin widths\nθ_lims: Angle bin limits\n\nReturns\n\nmatrices::TransportMatrices: Initialized container for the transport matrices\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.interpolate_O_parameters-Tuple{Any}","page":"Reference","title":"AURORA.interpolate_O_parameters","text":"interpolate_O_parameters(E_primary)\n\nInterpolate energy-dependent parameters for atomic O ionization.\n\nArguments\n\nE_primary: Primary electron energy (eV)\n\nReturns\n\n(A_factor, B_factor): Tuple of interpolated parameters\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.interpolate_iri_to_grid-Tuple{Any, Any}","page":"Reference","title":"AURORA.interpolate_iri_to_grid","text":"interpolate_iri_to_grid(iri_data, h_atm)\n\nInterpolate IRI data to a custom altitude grid.\n\nThis function interpolates all altitude-dependent densities and temperatures from IRI to a new altitude grid, while preserving scalar parameters (peak densities/heights, TEC, etc.).\n\nArguments\n\niri_data: NamedTuple from load_iri_data() or load_iri().data\nh_atm: Target altitude grid (m). Vector [nZ]\n\nReturns\n\nA NamedTuple with the same fields as iri_data, but with interpolated profiles:\n\nheight_km: converted target altitude grid (km). Vector [nZ]\nne: interpolated electron density (m⁻³). Vector [nZ]\nTn: interpolated neutral temperature (K). Vector [nZ]\nTi: interpolated ion temperature (K). Vector [nZ]\nTe: interpolated electron temperature (K). Vector [nZ]\nnO⁺, nH⁺, nHe⁺, etc.: interpolated ion densities (m⁻³). Vector [nZ]\nNmF2, hmF2, NmF1, etc.: preserved scalar parameters (unchanged from input)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.interpolate_msis_to_grid-Tuple{Any, Any}","page":"Reference","title":"AURORA.interpolate_msis_to_grid","text":"interpolate_msis_to_grid(msis_data, h_atm)\n\nInterpolate MSIS data to a custom altitude grid.\n\nThis function interpolates all altitude-dependent densities and temperature from MSIS to a new altitude grid. The interpolation is performed in log space for densities (which provides exponential extrapolation) and linear space for temperature.\n\nArguments\n\nmsis_data: NamedTuple from load_msis_data() or load_msis().data\nh_atm: Target altitude grid (m). Vector [nZ]\n\nReturns\n\nA NamedTuple with the following fields (all vectors of length nZ):\n\nheight_km: converted target altitude grid (km)\nN2: interpolated N₂ density (m⁻³)\nO2: interpolated O₂ density (m⁻³)\nO: interpolated O density (m⁻³)\nT: interpolated temperature (K)\n\nNotes\n\nDensities are interpolated in log space for better exponential behavior\nTemperature is interpolated in linear space\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.interpolate_profile-Tuple{Any, Any, Any}","page":"Reference","title":"AURORA.interpolate_profile","text":"interpolate_profile(data_values, data_altitude_km, target_altitude_m;\n                   log_interpolation=true)\n\nInterpolate a single profile from one altitude grid to another.\n\nThis is a helper function for interpolating individual data profiles. Interpolation can be performed in linear or logarithmic space.\n\nArguments\n\ndata_values::Vector: The data to interpolate (e.g., density or temperature)\ndata_altitude_km::Vector: Altitude grid of the input data (km)\ntarget_altitude_m::Vector: Target altitude grid for interpolation (m)\n\nKeyword Arguments\n\nlog_interpolation::Bool=true: If true, interpolation is done in log space (exponential   extrapolation). Recommended for densities. Use false for temperatures.\n\nReturns\n\ninterpolated::Vector: Interpolated data on the target altitude grid\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_cascading_matrices-Tuple{Any}","page":"Reference","title":"AURORA.load_cascading_matrices","text":"load_cascading_matrices(filepath)\n\nLoad pre-computed cascading matrices from a file.\n\nArguments\n\nfilepath: Path to the .mat file containing cascading data\n\nReturns\n\n(Q_transfer_matrix, E_grid_for_Q, ionization_thresholds): Tuple of loaded data\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_cross_sections-Tuple{Any, Any}","page":"Reference","title":"AURORA.load_cross_sections","text":"load_cross_sections(E, dE)\n\nLoad the cross-sections of the neutrals species for their different energy states.\n\nCalling\n\nσ_neutrals = load_cross_sections(E, dE)\n\nInputs\n\nE: energy grid (eV). Vector [nE]\ndE: energy grid step size (eV). Vector [nE]\n\nReturns\n\nσ_neutrals: A named tuple containing the cross-sections (m⁻²) for N2, O2, and O.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_electron_densities-Tuple{Any, Any}","page":"Reference","title":"AURORA.load_electron_densities","text":"load_electron_densities(iri_file, h_atm)\n\nLoad the electron density and temperature from an IRI file that was generated and saved using AURORA's IRI interface. Then interpolate the profiles over AURORA's altitude grid.\n\nCalling\n\nne, Te = load_electron_densities(iri_file, h_atm)\n\nInputs\n\niri_file: absolute path to the iri file to read ne and Te from. String\nh_atm: altitude (m). Vector [nZ]\n\nReturns\n\nne: e- density (m⁻³). Vector [nZ]\nTe: e- temperature (K). Vector [nZ]\n\nSee also\n\nload_iri, interpolate_iri_to_grid\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_excitation_threshold-Tuple{}","page":"Reference","title":"AURORA.load_excitation_threshold","text":"load_excitation_threshold()\n\nLoad the excitation thresholds or energy levels of the different states (vibrational, rotational, ionization, ...) of the neutrals species as specified in the XXlevels.dat files. The corresponding names of the states can be found in the XXlevels.name files. XX refers to N2, O2 or O.\n\nCalling\n\nE_levels_neutrals = load_excitation_threshold()\n\nReturns\n\nE_levels_neutrals: A named tuple of matrices, namely (N2_levels, O2_levels, O_levels).   The matrices have shape [n_levels x 2]. The first column contains the energy levels   and the second column contains the number of secondaries associated to that level (is   non-zero only for ionized states).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_iri-Tuple{Any}","page":"Reference","title":"AURORA.load_iri","text":"load_iri(iri_file)\n\nLoad an IRI file and return both parameters and data.\n\nArguments\n\niri_file: Path to the IRI file to load\n\nReturns\n\nA NamedTuple with two fields:\n\nparameters: NamedTuple with (year, month, day, hour, minute, lat, lon, height)\ndata: NamedTuple with all the IRI data columns\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_iri_data-Tuple{Any}","page":"Reference","title":"AURORA.load_iri_data","text":"load_iri_data(iri_file)\n\nLoad IRI model data from a file into a structured NamedTuple.\n\nReads an IRI data file and organizes all columns into a NamedTuple with descriptive field names for easy access to densities, temperatures, and other ionospheric parameters.\n\nArguments\n\niri_file::String: Path to the IRI data file\n\nReturns\n\nNamedTuple: IRI data with the following fields (all vectors except where noted):\nheight_km: Altitude grid (km)\nne: Electron density (m⁻³)\nTn: Neutral temperature (K)\nTi: Ion temperature (K)\nTe: Electron temperature (K)\nnO⁺, nH⁺, nHe⁺, nO2⁺, nNO⁺, nCI, nN⁺: Ion densities (m⁻³)\nNmF2, NmF1, NmE: Peak densities at F2, F1, E layers\nhmF2, hmF1, hmE: Peak heights at F2, F1, E layers (km)\nTEC: Total Electron Content\nEqVertIonDrift: Equatorial vertical ion drift\nfoF2: F2 critical frequency\n\nNotes\n\nAll profile data are vectors with length equal to the iri altitude grid\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_msis-Tuple{Any}","page":"Reference","title":"AURORA.load_msis","text":"load_msis(msis_file)\n\nLoad a MSIS file and return both parameters and data.\n\nArguments\n\nmsis_file: Path to the MSIS file to load\n\nReturns\n\nA NamedTuple with two fields:\n\nparameters: NamedTuple with (year, month, day, hour, minute, lat, lon, height)\ndata: NamedTuple with all the MSIS data columns\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_msis_data-Tuple{Any}","page":"Reference","title":"AURORA.load_msis_data","text":"load_msis_data(msis_file)\n\nLoad MSIS model data from a file into a structured NamedTuple.\n\nReads a MSIS data file and organizes all columns into a NamedTuple with descriptive field names for easy access to densities, temperature, and other atmospheric parameters.\n\nArguments\n\nmsis_file::String: Path to the MSIS data file\n\nReturns\n\nNamedTuple: MSIS data with the following fields (all vectors):\nheight_km: Altitude grid (km)\nair: Total mass density (kg/m³)\nN2: Molecular nitrogen density (m⁻³)\nO2: Molecular oxygen density (m⁻³)\nO: Atomic oxygen density (m⁻³)\nHe: Helium density (m⁻³)\nH: Atomic hydrogen density (m⁻³)\nAr: Argon density (m⁻³)\nN: Atomic nitrogen density (m⁻³)\nanomalousO: Anomalous oxygen density (m⁻³)\nNO: Nitric oxide density (m⁻³)\nT: Temperature (K)\n\nNotes\n\nAll data are vectors with length equal to the msis altitude grid\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_neutral_densities-Tuple{Any, Any}","page":"Reference","title":"AURORA.load_neutral_densities","text":"load_neutral_densities(msis_file, h_atm)\n\nLoad the neutral densities and temperature from a MSIS file that was generated and saved using AURORA's MSIS interface. Then interpolate the profiles over AURORA's altitude grid.\n\nUpper boundary conditions are applied to smoothly transition the densities to zero.\n\nCalling\n\nn_neutrals, Tn = load_neutral_densities(msis_file, h_atm)\n\nInputs\n\nmsis_file: absolute path to the msis file to read n_neutrals and Tn from. String\nh_atm: altitude (m). Vector [nZ]\n\nReturns\n\nn_neutrals: neutral densities (m⁻³). Named tuple of vectors ([nZ], ..., [nZ])\nTn: neutral temperature (K). Vector [nZ]\n\nSee also\n\nload_msis, interpolate_msis_to_grid\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_parameters_iri-Tuple{Any}","page":"Reference","title":"AURORA.load_parameters_iri","text":"load_parameters_iri(iri_file)\n\nLoad calculation parameters from an IRI data file header.\n\nReads the header section of an IRI file and extracts the input parameters that were used for the IRI model calculation.\n\nArguments\n\niri_file::String: Path to the IRI data file\n\nReturns\n\nNamedTuple: Parameters with fields:\nyear::Int: Year\nmonth::Int: Month (1-12)\nday::Int: Day (1-31)\nhour::Int: Hour (0-23)\nminute::Int: Minute (0-59)\nlat::Real: Latitude (degrees North)\nlon::Real: Longitude (degrees East)\nheight::AbstractRange: Altitude range (km)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_parameters_msis-Tuple{Any}","page":"Reference","title":"AURORA.load_parameters_msis","text":"load_parameters_msis(msis_file)\n\nLoad calculation parameters from a MSIS data file header.\n\nReads the header section of a MSIS file and extracts the input parameters that were used for the MSIS model calculation.\n\nArguments\n\nmsis_file::String: Path to the MSIS data file\n\nReturns\n\nNamedTuple: Parameters with fields:\nyear::Int: Year\nmonth::Int: Month (1-12)\nday::Int: Day (1-31)\nhour::Int: Hour (0-23)\nminute::Int: Minute (0-59)\nlat::Real: Latitude (degrees North)\nlon::Real: Longitude (degrees East)\nheight::AbstractRange: Altitude range (km)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.load_scattering_matrices-Tuple{Any}","page":"Reference","title":"AURORA.load_scattering_matrices","text":"load_scattering_matrices(θ_lims)\n\nCreate an energy grid based on the maximum energy E_max given as input.\n\nCalling\n\nμ_lims, μ_center, μ_scatterings = load_scattering_matrices(θ_lims)\n\nInputs\n\nθ_lims: pitch angle limits of the e- beams (deg). Vector [n_beam + 1]\n\nOutputs\n\nμ_lims: cosine of the pitch angle limits of the e- beams. Vector [n_beam + 1]\nμ_center: cosine of the pitch angle of the middle of the e- beams. Vector [n_beam]\nμ_scatterings: Tuple with several of the scattering informations, namely μ_scatterings   = (Pmu2mup, BeamWeight_relative, BeamWeight)\nPmu2mup: probabilities for scattering in 3D from beam to beam. Matrix [n_direction x n_direction]\nBeamWeight_relative: relative contribution from within each beam. Matrix [n_beam x n_direction]\nBeamWeight: solid angle for each stream (ster). Vector [n_beam]\ntheta1: scattering angles used in the calculations. Vector [n_direction]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.loss_to_thermal_electrons-Tuple{Real, Any, Any}","page":"Reference","title":"AURORA.loss_to_thermal_electrons","text":"loss_to_thermal_electrons(E, ne, Te)\n\nSuprathermal electron energy loss function due to electron-electron collisions.\n\nThis function calculates the electron energy loss function due to electron-electron interaction. It uses the analytic form given for the energy-transfer rate from photoelectrons (or suprathermal electrons) to thermal electrons, given by Swartz and Nisbet (1971). The expression fits the classical formulation of Itikawa and Aono (1966) at low energies and gives a smooth transition to fit the quantum mechanical equation of Schunk and Hays (1971).\n\nArguments\n\nE::Real: Energy level [eV]. Scalar value.\nne::Vector: Ambient electron concentration [/m³], length nZ.\nTe::Vector: Electron temperature [K], length nZ.\n\nReturns\n\nLe::Vector: Electron energy loss function [eV/m], length nZ.\n\nNotes\n\nThe paper by Swartz and Nisbet uses electron density in cm⁻³; here the constant is rescaled to use m⁻³ instead. We calculate the loss function dE/ds(E,ne,Te) directly and not as in Swartz and Nisbet dE/ds(E,ne,Te)/ne.\n\nThe loss is set to zero when the suprathermal electron energy E is below the thermal electron energy Ee = kB*Te/qₑ.\n\nReferences\n\nSwartz, W. E., J. S. Nisbet, and A. E. S. Green (1971), Analytic expression for the energy transfer rate from photoelectrons to thermal electrons, J. Geophys. Res., 76(34), 8425-8426, doi: 10.1029/JA076i034p08425.\nItikawa, Y., and O. Aono (1966), Energy change of a charged particle moving in a plasma, Phys. Fluids, 9, 1259-1261.\nSchunk, R. W., and P. B. Hays (1971), Photoelectron energy losses to thermal electrons, Planet. Space Sci., 19, 113-117.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.make_Ie_top_file-Tuple{Any}","page":"Reference","title":"AURORA.make_Ie_top_file","text":"make_Ie_top_file(directory_to_process)\n\nReads into a folder directory_to_process containing results from an AURORA.jl simulation and extracts the particle flux Ie (#e⁻/m²/s) at the top of the ionosphere (i.e. at the max altitude used in the simulation).\n\nCalling\n\nmake_Ie_top_file(directory_to_process)\n\nInputs\n\ndirectory_to_process: absolute or relative path to the simulation directory to process.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.make_altitude_grid-Tuple{Any, Any}","page":"Reference","title":"AURORA.make_altitude_grid","text":"make_altitude_grid(bottom_altitude, top_altitude; dz_max=25)\n\nCreate an altitude grid based on the altitude limits given as input. It uses constant steps of 150m for altitudes below 100km, and a non-linear grid above 100km.\n\nCalling\n\n`hatm = makealtitudegrid(bottomaltitude, topaltitude; maxdz=25)\n\nArguments\n\nbottom_altitude: altitude, in km, for the bottom of the simulation\ntop_altitude: altitude, in km, for the top of the simulation\n\nKeyword Arguments\n\ndz_max = 25: maximum step size, in km. Relevant for high altitudes where the numbers   can get large.\n\nOutputs\n\nh_atm: altitude (m). Vector [nZ]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.make_column_excitation_file-Tuple{Any}","page":"Reference","title":"AURORA.make_column_excitation_file","text":"make_column_excitation_file(directory_to_process)\n\nReads into a folder directory_to_process containing results from an AURORA.jl simulation, loads the volume excitation rates Q_XXXX (#excitation/m³/s) contained in the file Qzt_all_L.mat and integrate them in height, taking into account the finite speed of light.\n\nThe calculated colum-integrated excitation rates are saved to a file named I_lambda_of_t.mat. The column-integrated excitation rates are named \"I_4278, I_6730, ...\". They are all vectors in time (length n_t), and have units of (#excitation/m²/s).\n\nNote that the function make_volume_excitation_file() needs to be run before this one, as we need the file Qzt_all_L.mat with the volume excitation rates.\n\nCalling\n\nmake_current_file(directory_to_process)\n\nInputs\n\ndirectory_to_process: absolute or relative path to the simulation directory to process.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.make_current_file-Tuple{Any}","page":"Reference","title":"AURORA.make_current_file","text":"make_current_file(directory_to_process)\n\nReads into a folder directory_to_process containing results from an AURORA.jl simulation, loads the particle flux Ie (#e⁻/m²/s) and calculates the field-aligned current-density and field-aligned energy-flux for each height and through time.\n\nThe following variables are saved to a file named J.mat:\n\nJ_up: Field-aligned current-density in the upward direction. 2D array [n_z, n_t]\nJ_down: Field-aligned current-density in the downward direction. 2D array [n_z, n_t]\nE_up: Field-aligned energy-flux (eV/m²/s) in the upward direction. 2D array [n_z, n_t]\nE_down: Field-aligned energy-flux (eV/m²/s) in the downward direction. 2D array [n_z, n_t]\n\nCalling\n\nmake_current_file(directory_to_process)\n\nInputs\n\ndirectory_to_process: absolute or relative path to the simulation directory to process.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.make_density_file-Tuple{Any}","page":"Reference","title":"AURORA.make_density_file","text":"make_density_file(directory_to_process)\n\nThis function reads into a folder directory_to_process containing results from an AURORA.jl simulation. It loads the particle flux Ie (#e⁻/m²/s), calculates the superthermal e- density n_e (#e⁻/m³) from it, and saves n_e into a new file \"superthermal_e_density.mat\".\n\nThe particle flux Ie is defined along a magnetic field line and over an (Energy, pitch_angle)-grid. The number density n_e calculated is given along a magnetic field line and over an energy grid. That way, we have the density of electrons with a certain energy at a specific altitude and time.\n\nCalling\n\nmake_density_file(directory_to_process)\n\nInputs\n\ndirectory_to_process: absolute or relative path to the simulation directory to process\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.make_energy_grid-Tuple{Any}","page":"Reference","title":"AURORA.make_energy_grid","text":"make_energy_grid(E_max)\n\nCreate an energy grid based on the maximum energy E_max given as input.\n\nCalling\n\nE, dE = make_energy_grid(E_max)\n\nInputs\n\nE_max: upper limit for the energy grid (in eV)\n\nOutputs\n\nE: energy grid (eV). Vector [nE]\ndE: energy bin sizes(eV). Vector [nE]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.make_heating_rate_file-Tuple{Any}","page":"Reference","title":"AURORA.make_heating_rate_file","text":"make_heating_rate_file(directory_to_process)\n\nReads into a folder directory_to_process containing results from an AURORA.jl simulation, loads the particle flux Ie (#e⁻/m²/s), and calculates the heating rate of thermal electrons by superthermal electrons.\n\nThe heating rate is the rate at which energy is transferred from superthermal electrons to thermal electrons through Coulomb collisions. It is saved as a function of altitude and time.\n\nCalling\n\nmake_heating_rate_file(directory_to_process)\n\nInputs\n\ndirectory_to_process: absolute or relative path to the simulation directory to process.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.make_savedir-Tuple{Any, Any}","page":"Reference","title":"AURORA.make_savedir","text":"make_savedir(root_savedir, name_savedir; behavior = \"default\")\n\nReturn the path to the directory where the results will be saved. If the directory does not already exist, create it.\n\nIf the constructed savedir already exists and contains files starting with \"IeFlickering-\", a new directory is created to avoid accidental overwriting of results (e.g., savedir(1), savedir(2), etc.).\n\nCalling\n\nsavedir = make_savedir(root_savedir, name_savedir) \nsavedir = make_savedir(root_savedir, name_savedir; behavior = \"custom\")\n\nArguments\n\nroot_savedir::String: The root directory where the data will be saved. If empty or   contains only spaces, it defaults to \"backup\".\nname_savedir::String: The name of the subdirectory to be created within root_savedir.   If empty or contains only spaces, it defaults to the current date and time in the   format \"yyyymmdd-HHMM\".\nbehavior::String (optional): Determines how the full path is constructed.\n\"default\": The path will be built starting under the data/ folder of the AURORA installation   (i.e., AURORA_folder/data/root_savedir/name_savedir/, where AURORA_folder is   the folder containing the AURORA code). This is the default behavior.\n\"custom\": The path will be built as root_savedir/name_savedir/, with the argument   root_savedir treated as an absolute or relative path. This allows for saving results   in any location on the system. Useful if AURORA is installed as a dependency to some   other project.\n\nReturns\n\nsavedir::String: The full path to the directory where the results will be saved.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.make_volume_excitation_file-Tuple{Any}","page":"Reference","title":"AURORA.make_volume_excitation_file","text":"make_volume_excitation_file(directory_to_process)\n\nReads into a folder directory_to_process containing results from an AURORA.jl simulation, loads the particle flux Ie (#e⁻/m²/s), and calculates the volume-excitation-rates. For prompt emissions, volume-excitation-rates correspond also to volume-emission-rates.\n\nCalling\n\nmake_volume_excitation_file(directory_to_process)\n\nInputs\n\ndirectory_to_process: absolute or relative path to the simulation directory to process.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.mu_avg-Tuple{Any}","page":"Reference","title":"AURORA.mu_avg","text":"mu_avg(θ_lims)\n\nCalculate the cosinus of the center of each pitch-angle beams delimited by θ_lims. This is for isotropically distributed fluxes within each beam, i.e the fluxes are weighted by sin(θ)\n\nCalling\n\nμ_center = mu_avg(θ_lims)\n\nInputs\n\nθ_lims : pitch-angle limits in degrees of all the beams, range or vector [n_beams + 1]\n\nOutputs\n\nμ_center : cosine of the center of all the pitch-angle beams, vector [n_beams + 1]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.q2colem","page":"Reference","title":"AURORA.q2colem","text":"q2colem(t::Vector, h_atm, Q, A = 1, τ = ones(length(h_atm)))\n\nIntegrate the volume-excitation-rate (#exc/m³/s) to column-excitation-rate (#exc/m²/s).\n\nTakes into account the time-delay between light emitted at different altitudes. Photons emitted at at altitude of 200km will arrive at the detector 100e3/3e8 = 0.333 ms later than electrons emitted at an altitude of 100km. This is a small time-shift, but it is close to the time-differences corresponding to the phase-shifts between auroral emissions varying at ~10Hz.\n\nThe einstein coefficient A and effective lifetime τ are optional (equal to one by default).\n\nCalling\n\nI = q2colem(t, h_atm, Q, A, τ)\n\nInputs\n\nh_atm: altitude (m). Vector [n_z]\nt: time (s). Vector [n_t]\nQ: volume-excitation-rate (#exc/m³/s) of the wavelength of interest. 2D array [n_z, n_t]\nA: einstein coefficient (s⁻¹). Scalar (Float or Int)\nτ: effective lifetime (s). Vector [n_z].\n\nOutput\n\nI: integrated column-excitation-rate (#exc/m²/s) of the wavelength of interest. Vector [n_t]\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.q2colem-2","page":"Reference","title":"AURORA.q2colem","text":"q2colem(t::Real, h_atm, Q, A = 1, τ = ones(length(h_atm)))\n\nSame as above, except time is now a scalar (steady-state results). This is just a simple integration in height.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AURORA.rename_if_exists-Tuple{Any}","page":"Reference","title":"AURORA.rename_if_exists","text":"rename_if_exists(savefile)\n\nThis function takes a string as an input. If a file or folder with that name does not exist, it returns the same string back. But if the folder or file already exists, it appends a number between parenthesis to the name string.\n\nFor example, if the folder foo/ already exist and \"foo\" is given as input, the function will return a string \"foo(1)\" as an output. Similarly, if a file foo.txt already exists and \"foo.txt\" is given as input, the function will return a string \"foo(1).txt\". If the file foo(1).txt also already exist, the function will return a string \"foo(2).txt\", etc...\n\nThe function should support all types of extensions.\n\nCalling\n\nnewsavefile = rename_if_exists(savefile)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.restructure_streams_of_Ie-Tuple{Any, Any, Any}","page":"Reference","title":"AURORA.restructure_streams_of_Ie","text":"restructure_streams_of_Ie(Ie, θ_lims, new_θ_lims)\n\nFunction that merges the streams of Ie that are given over θ_lims to fit the new_θ_lims of interest. It can be useful when wanting to merge some streams for plotting.\n\nFor example, if we have θ_lims = [180 160 140 120 100 90 80 60 40 20 0], and we want to plot with new_θ_lims = [(180, 160), (160, 120)], the function will keep the first stream as is and merge the streams (160°-140°) and (140°-120°) together into a new stream with limits (160°-120°).\n\nImportant: The limits in new_θ_lims need to match some existing limits in θ_lims. In the example above, new_θ_lims = [(180, 165)] would not have worked because 165° is not a limit that exists in θ_lims.\n\nEntries in new_θ_lims can be nothing to leave a panel empty.\n\nCalling\n\nIe_plot = restructure_streams_of_Ie(Ie, θ_lims, new_θ_lims)\n\nArguments\n\nIe: array of electron flux with pitch-angle limits θ_lims. Of shape [n_μ, n_z, n_t, n_E].\nθ_lims: pitch-angle limits. Usually a vector or range.\nnew_θ_lims: new pitch-angle limits. Given as an array of tuples with angles in the range               0-180° (where 180° is field-aligned down, 0° is field-aligned up). Use nothing               for empty panels. For example:\n\njulia> new_θ_lims = [(180, 170)  (170, 150)  (150, 120)  (120, 100)  (100, 90);  # DOWN\n                     (0, 10)     (10, 30)    (30, 60)    (60, 80)    (80, 90)]   # UP\n\nReturns\n\nIe_plot: array of electron flux with the new pitch-angle limits new_θ_lims. Of shape            [n_μ_new, n_z, n_t, n_E], where n_μ_new is the number of streams            in new_θ_lims. The first dimension of Ie_plot is sorted such that the            indices go along the first row of new_θ_lims, and then the second row.            In our example with new_θ_lims from above, that would be 1 2 3 4 5 6 7 8 9 10.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.save_cascading_matrices-NTuple{5, Any}","page":"Reference","title":"AURORA.save_cascading_matrices","text":"save_cascading_matrices(Q_transfer_matrix, E_grid_for_Q, ionization_thresholds, species_dir, species_name)\n\nSave calculated cascading matrices to a file.\n\nArguments\n\nQ_transfer_matrix: Transfer matrix to save\nE_grid_for_Q: Energy grid used for calculations\nionization_thresholds: Ionization threshold energies\nspecies_dir: Directory to save the file\nspecies_name: Name of the species (for filename)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.save_iri_data-Tuple{Any, Any}","page":"Reference","title":"AURORA.save_iri_data","text":"save_iri_data(iri_data, parameters)\n\nSave IRI model data to a text file with metadata header.\n\nCreates a formatted text file containing the IRI calculation parameters in the header followed by the data matrix. The filename is automatically generated based on the input parameters, and if a file with the same name exists, a unique name is created.\n\nArguments\n\niri_data::Matrix: IRI data matrix from calculate_iri_data() (with header row)\nparameters::NamedTuple: Parameters used for IRI calculation, must contain:\nyear, month, day, hour, minute: Time specification\nlat, lon: Location (degrees)\nheight: Altitude range (km)\n\nReturns\n\nString: Full path to the created file\n\nFile Format\n\nThe file contains:\n\nHeader section with input parameters\nColumn headers\nData matrix (one row per altitude)\n\nFilename Convention\n\niri_YYYYMMDD-HHMM_LATN-LONE.txt\n\nNotes\n\nFiles are saved to internal_data/data_electron/ directory\nExisting files are not overwritten; a suffix is added to the filename\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.save_msis_data-Tuple{Any, Any}","page":"Reference","title":"AURORA.save_msis_data","text":"save_msis_data(msis_data, parameters)\n\nSave MSIS model data to a text file with metadata header.\n\nCreates a formatted text file containing the MSIS calculation parameters in the header followed by the data matrix. The filename is automatically generated based on the input parameters, and if a file with the same name exists, a unique name is created.\n\nArguments\n\nmsis_data::Matrix: MSIS data matrix from calculate_msis_data() (with header row)\nparameters::NamedTuple: Parameters used for MSIS calculation, must contain:\nyear, month, day, hour, minute: Time specification\nlat, lon: Location (degrees)\nheight: Altitude range (km)\n\nReturns\n\nString: Full path to the created file\n\nFile Format\n\nThe file contains:\n\nHeader section with input parameters\nColumn headers\nData matrix (one row per altitude)\n\nFilename Convention\n\nmsis_YYYYMMDD-HHMM_LATN-LONE.txt\n\nNotes\n\nFiles are saved to internal_data/data_neutrals/ directory\nExisting files are not overwritten; a suffix is added to the filename\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.search_existing_iri_file-Tuple{}","page":"Reference","title":"AURORA.search_existing_iri_file","text":"search_existing_iri_file(; year, month, day, hour, minute, lat, lon, height)\n\nSearch for an existing IRI data file matching the specified parameters.\n\nThis function scans the internal_data/data_electron/ directory for IRI files with matching time, location, and altitude grid parameters. It performs a quick pre-check on filenames before loading and comparing full parameters.\n\nKeyword Arguments\n\nyear::Int: Year\nmonth::Int: Month (1-12)\nday::Int: Day of month (1-31)\nhour::Int: Hour in Universal Time (0-23)\nminute::Int: Minute (0-59)\nlat::Real: Geographic latitude in degrees North\nlon::Real: Geographic longitude in degrees East\nheight::AbstractRange: Altitude range in km\n\nReturns\n\nUnion{String, Nothing}: Full path to matching file, or nothing if not found\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.search_existing_msis_file-Tuple{}","page":"Reference","title":"AURORA.search_existing_msis_file","text":"search_existing_msis_file(; year, month, day, hour, minute, lat, lon, height)\n\nSearch for an existing MSIS data file matching the specified parameters.\n\nThis function scans the internal_data/data_neutrals/ directory for MSIS files with matching time, location, and altitude grid parameters. It performs a quick pre-check on filenames before loading and comparing full parameters.\n\nKeyword Arguments\n\nyear::Int: Year\nmonth::Int: Month (1-12)\nday::Int: Day of month (1-31)\nhour::Int: Hour in Universal Time (0-23)\nminute::Int: Minute (0-59)\nlat::Real: Geographic latitude in degrees North\nlon::Real: Geographic longitude in degrees East\nheight::AbstractRange: Altitude range in km\n\nReturns\n\nUnion{String, Nothing}: Full path to matching file, or nothing if not found\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.setup-NTuple{5, Any}","page":"Reference","title":"AURORA.setup","text":"setup(altitude_lims, θ_lims, E_max, msis_file, iri_file)\n\nLoad the atmosphere, the energy grid, the collision cross-sections, ...\n\nCalling\n\nh_atm, ne, Te, Tn, E, dE, n_neutrals, E_levels_neutrals, σ_neutrals, θ_lims, μ_lims, μ_center, μ_scatterings = setup(altitude_lims, θ_lims, E_max, msis_file, iri_file)\n\nInputs\n\naltitude_lims: the altitude limits, in km, for the bottom and top of the ionosphere in our simulation\nθ_lims: pitch-angle limits of the electron beams (e.g. 180:-10:0), where 180°   corresponds to field aligned down, and 0° field aligned up. Vector [n_beam]\nE_max: upper limit for the energy grid (in eV)\nmsis_file: path to the msis file to use\niri_file: path to the iri file to use\n\nOutputs\n\nh_atm: altitude (m). Vector [nZ]\nne: e- density (m⁻³). Vector [nZ]\nTe: e- temperature (K). Vector [nZ]\nTn: neutral temperature (K). Vector [nZ]\nE: energy grid (eV). Vector [nE]\ndE: energy bin sizes(eV). Vector [nE]\nn_neutrals: neutral densities (m⁻³). Named tuple of vectors ([nZ], ..., [nZ])\nE_levels_neutrals: collisions energy levels and number of secondary e- produced. Named   tuple of matrices ([n_levels x 2], ..., [n_levels x 2])\nσ_neutrals: collision cross-sections (m⁻²). Named tuple of matrices ([n_levels x nE],   ..., [n_levels x nE])\nθ_lims: pitch angle limits of the e- beams (deg). Vector [n_beam + 1]\nμ_lims: cosine of the pitch angle limits of the e- beams. Vector [n_beam + 1]\nμ_center: cosine of the pitch angle of the middle of the e- beams. Vector [n_beam]\nμ_scatterings: Named tuple with several of the scattering informations, namely   μ_scatterings = (Pmu2mup, BeamWeight_relative, BeamWeight)\nPmu2mup: probabilities for scattering in 3D from beam to beam. Matrix [n_direction x n_direction]\nBeamWeight_relative: relative contribution from within each beam. Matrix [n_beam x n_direction]\nBeamWeight: solid angle for each stream (ster). Vector [n_beam]\ntheta1: scattering angles used in the calculations. Vector [n_direction]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.steady_state_scheme_optimized!-NTuple{7, Any}","page":"Reference","title":"AURORA.steady_state_scheme_optimized!","text":"steady_state_scheme_optimized!(Ie, h_atm, μ, matrices, iE, Ie_top, cache; first_iteration = false)\n\nOptimized steady-state scheme using direct nzval modification. This is an in-place version that modifies Ie directly to avoid allocations. This version avoids allocations by reusing the sparse matrix structure.\n\nOn first iteration, creates the sparsity pattern and mapping which are stored in cache. On subsequent iterations, only updates the nzval array directly.\n\nMathematical Background\n\nThe steady-state electron transport equation is:\n\nμ ∂Ie/∂z + A*Ie - ∫B*Ie'dΩ' = Q\n\nAfter spatial discretization, this becomes a linear system of coupled equations:\n\n[μ*Ddz + A - B - D*Ddiffusion] * Ie = Q\n         ↑\n        Mlhs (the system matrix)\n\nWhere:\n\nDdz = Ddz_Up or Ddz_Down (depending on sign of μ): spatial derivative operator\nA: electron loss rate matrix (diagonal)\nB: scattering operator matrix (couples different angles)\nD: diffusion coefficient (diagonal in angle space)\nDdiffusion: second derivative operator for pitch-angle diffusion\nQ: source term (energy degradation and ionization)\n\nThe resulting sparse matrix Mlhs has a block structure:\n\n┌─────────┬─────────┬─────────┐\n│ Block   │ Block   │ Block   │  Each block is n_z × n_z\n│ (1,1)   │ (1,2)   │ (1,3)   │  (n_z = number of altitudes)\n├─────────┼─────────┼─────────┤\n│ Block   │ Block   │ Block   │  Off-diagonal blocks (i1≠i2):\n│ (2,1)   │ (2,2)   │ (2,3)   │  represent angular scattering (B matrix)\n├─────────┼─────────┼─────────┤\n│ Block   │ Block   │ Block   │  Diagonal blocks (i1=i2):\n│ (3,1)   │ (3,2)   │ (3,3)   │  transport + loss + diffusion\n└─────────┴─────────┴─────────┘\n\nIn the context of solving f(Ie) = Mlhs*Ie - Q = 0, the matrix Mlhs is the Jacobian:\n\nJacobian = ∂f/∂Ie = Mlhs\n\nArguments\n\nIe: pre-allocated output array [m⁻² s⁻¹], size (nz * nangle) to store results\nh_atm: altitude grid [km]\nμ: cosine of pitch angle grid\nmatrices::TransportMatrices: container with\nA: electron loss rate [s⁻¹]\nB: scattering matrix [s⁻¹], size (nz × nangle × n_angle)\nD: pitch-angle diffusion coefficient [s⁻¹], size (n_angle,)\nQ: source term [m⁻² s⁻¹], size (nz × nangle × n_energy)\nDdiffusion: spatial diffusion matrix, size (nz × nz)\niE: current energy index\nIe_top: boundary condition at top [m⁻² s⁻¹]\ncache: Cache object storing Mlhs, mapping, KLU, and differentiation matrices\nfirst_iteration: whether this is the first call (creates structure) or subsequent (reuses structure)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.update_crank_nicolson_matrices!-NTuple{13, Any}","page":"Reference","title":"AURORA.update_crank_nicolson_matrices!","text":"update_crank_nicolson_matrices!(Mlhs, Mrhs, mapping_lhs, mapping_rhs,\n                                A, B, D, Ddt, Ddiffusion, Ddz_Up, Ddz_Down, μ, h_atm)\n\nUpdate both Mlhs and Mrhs using pre-computed mappings. This is the fast path with zero allocations.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.update_matrices!-Tuple{AURORA.TransportMatrices, Vararg{Any, 11}}","page":"Reference","title":"AURORA.update_matrices!","text":"update_matrices!(matrices, n_neutrals, σ_neutrals, ne, Te, E_levels_neutrals,\n                 phase_fcn_neutrals, E, dE, iE, B2B_fragment, finer_θ)\n\nUpdate the A and B matrices in place for a given energy level iE.\n\nArguments\n\nmatrices::TransportMatrices: Container to update\nn_neutrals, σ_neutrals, ne, Te, E_levels_neutrals, phase_fcn_neutrals: Atmosphere and cross section data\nE, dE, iE: Energy grid and current energy index\nB2B_fragment, finer_θ: Pre-computed beam-to-beam fragments and angle grid\n\nReturns\n\nB2B_inelastic_neutrals: Array of inelastic beam-to-beam matrices for cascading calculations\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.update_steady_state_matrix!-NTuple{10, Any}","page":"Reference","title":"AURORA.update_steady_state_matrix!","text":"update_steady_state_matrix!(Mlhs, mapping, A, B, D, Ddiffusion, Ddz_Up, Ddz_Down, μ, h_atm)\n\nUpdate the sparse matrix values using pre-computed mapping. This avoids all allocations by directly modifying nzval.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.v_of_E-Tuple{Any}","page":"Reference","title":"AURORA.v_of_E","text":"v_of_E(E)\n\nCalculate the velocity (in m/s) of an electron with energy E (in eV).\n\nCalling\n\nv = v_of_E(E)\n\nInput\n\nE : energy in eV, can be a scalar, vector, range, ...\n\nOutput\n\nv : velocity in m/s\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#AURORA.validate_θ_lims-Tuple{Any}","page":"Reference","title":"AURORA.validate_θ_lims","text":"validate_θ_lims(θ_lims)\n\nValidate that the pitch-angle limits θ_lims are correctly specified. Throws an ArgumentError if:\n\nθ_lims does not include 180° (field-aligned downward)\nθ_lims does not include 0° (field-aligned upward)\nθ_lims is not in descending order\n\nInputs\n\nθ_lims: pitch-angle limits of the electron beams (e.g. 180:-10:0)\n\n\n\n\n\n","category":"method"},{"location":"10-manual/10-get_started/#Get-started","page":"Get started","title":"Get started","text":"Simulations are started using the function calculate_e_transport(...). The function takes in many parameters, so it can be easier to use the script named Control_script.jl situated in the scripts/ folder. The script is pre-filled and you just need to modify the values of the parameters. You can also use the script as a template to make your own control scripts.\n\nAfter you have modified the Control_script.jl and saved it, you just have to  execute it. This can be done from the Julia REPL or from the command line. ","category":"section"},{"location":"10-manual/10-get_started/#Starting-simulation-from-the-Julia-REPL","page":"Get started","title":"Starting simulation from the Julia REPL","text":"warning: Activating the AURORA environment\nTo be able to use AURORA.jl, the repository environment needs to be activated. This can be done for example by starting Julia from the AURORA.jl/ folder using the command$> julia --project=.Or by entering the Pkg REPL using the ] key and typingpkg> activate .\n\ninfo: Using VS Code\nIf you are using VS Code with the Julia extension, the local environment should be automatically activated when you open the AURORA.jl/ folder.\n\nOnce the AURORA.jl environment activated, you can start simulations from the Julia REPL with the command\n\njulia> include(\"scripts/Control_script.jl\")\n\nIf you are using VS Code, you can also use the \"Execute active File in REPL\" button.\n\nThe results will be saved in a folder under data/ along with the parameters used to run the simulation.","category":"section"},{"location":"10-manual/10-get_started/#Starting-simulation-from-the-command-line","page":"Get started","title":"Starting simulation from the command line","text":"Move to the AURORA.jl/ folder. Then, execute the Control_script.jl using the command \n\n$> julia --project=@. scripts/Control_script.jl \n\nThe results will be saved in a folder under data/ along with the parameters used to run the simulation.","category":"section"},{"location":"85-troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"85-troubleshooting/#IRI-and-MSIS-data","page":"Troubleshooting","title":"IRI and MSIS data","text":"You might run into some issues when trying to load/generate some msis or iri  data for the first time. This is because AURORA uses the pymsis and iri2016  python packages as dependencies. These packages use in turn some fortran dependencies. This should be normally handled by CondaPkg which is used  internally in AURORA, but if your system is complaining about missing fortran  compiler or missing cmake install, you might want to try running the following  commands in a terminal (on Linux):\n\n$> sudo apt update\n$> sudo apt install cmake\n$> sudo apt install gfortran","category":"section"},{"location":"20-api/atmosphere/#Ionospheric-Background-Models","page":"Ionospheric Background Models","title":"Ionospheric Background Models","text":"","category":"section"},{"location":"20-api/atmosphere/#MSIS-(Neutral-Atmosphere)","page":"Ionospheric Background Models","title":"MSIS (Neutral Atmosphere)","text":"","category":"section"},{"location":"20-api/atmosphere/#IRI-(Ionosphere)","page":"Ionospheric Background Models","title":"IRI (Ionosphere)","text":"","category":"section"},{"location":"20-api/atmosphere/#AURORA.find_msis_file-20-api-atmosphere","page":"Ionospheric Background Models","title":"AURORA.find_msis_file","text":"find_msis_file(; year=2018, month=12, day=7, hour=11, minute=15,\n                lat=76, lon=5, height=85:1:700)\n\nFind or create a MSIS model data file for the specified conditions.\n\nIt first searches for an existing MSIS file matching the given parameters. If no matching file is found, it calculates new MSIS data using the Python pymsis package and saves it to a file. The pymsis package will download, compile and run some fortran code under the hood.\n\nKeyword Arguments\n\nyear::Int=2018: Year\nmonth::Int=12: Month (1-12)\nday::Int=7: Day of month (1-31)\nhour::Int=11: Hour in Universal Time (0-23)\nminute::Int=15: Minute (0-59)\nlat::Real=76: Geographic latitude in degrees North\nlon::Real=5: Geographic longitude in degrees East\nheight::AbstractRange=85:1:700: Altitude range in km\n\nReturns\n\nString: Full path to the MSIS data file\n\nNotes\n\nDefault parameters correspond to the VISIONS-2 rocket launch conditions\nFiles are stored in internal_data/data_neutrals/ directory\n\n\n\n\n\n","category":"function"},{"location":"20-api/atmosphere/#AURORA.find_iri_file-20-api-atmosphere","page":"Ionospheric Background Models","title":"AURORA.find_iri_file","text":"find_iri_file(; year=2018, month=12, day=7, hour=11, minute=15,\n                lat=76, lon=5, height=85:1:700)\n\nFind or create an IRI model data file for the specified conditions.\n\nIt first searches for an existing IRI file matching the given parameters. If no matching file is found, it calculates new IRI data using the Python iri2016 package and saves it to a file. The iri2016 package will compile and run some fortran code under the hood.\n\nKeyword Arguments\n\nyear::Int=2018: Year\nmonth::Int=12: Month (1-12)\nday::Int=7: Day of month (1-31)\nhour::Int=11: Hour in Universal Time (0-23)\nminute::Int=15: Minute (0-59)\nlat::Real=76: Geographic latitude in degrees North\nlon::Real=5: Geographic longitude in degrees East\nheight::AbstractRange=85:1:700: Altitude range in km\n\nReturns\n\nString: Full path to the IRI data file\n\nNotes\n\nDefault parameters correspond to the VISIONS-2 rocket launch conditions\nFiles are stored in internal_data/data_electron/ directory\n\n\n\n\n\n","category":"function"},{"location":"20-api/visualization/#Visualization","page":"Visualization","title":"Visualization","text":"AURORA.jl provides functions to visualize and animate simulation results. \n\nCurrently, the only animation function available is animate_Ie_in_time.","category":"section"},{"location":"20-api/visualization/#Requirements","page":"Visualization","title":"Requirements","text":"The plotting and animation functions require a Makie backend.\n\nWe recommend:\n\nGLMakie - if you have a GPU. It is fast and interactive\nCairoMakie - if you work on a server without a GPU or want high quality figures (e.g. for publication). It is however non-interactive and slower than GLMakie\n\nnote: Installing Makie\nYou need to install GLMakie or CairoMakie yourself, for example  in your global Julia environment (@v1.XX)\n\nTo use the visualization functions, import a backend before or after importing AURORA\n\n# For example\nusing AURORA\nusing GLMakie\n\n# Do some visualization","category":"section"},{"location":"20-api/visualization/#Functions","page":"Visualization","title":"Functions","text":"","category":"section"},{"location":"20-api/visualization/#AURORA.animate_Ie_in_time-20-api-visualization","page":"Visualization","title":"AURORA.animate_Ie_in_time","text":"animate_Ie_in_time(directory_to_process; angles_to_plot=nothing, colorrange=nothing, ...)\n\nPlot a heatmap of Ie over height and energy, and animate it in time. It will load the result files one by one. The animation will be saved as a .mp4 file under the directory_to_process.\n\nExample\n\njulia> directory_to_process = \"Visions2/Alfven_475s\";\n\n# Using defaults for angles and colorrange:\njulia> animate_Ie_in_time(directory_to_process)\n\n# Or with custom angles and colorrange:\njulia> angles_to_plot = [(180, 170)  (170, 150)  (150, 120)  (120, 100)  (100, 90);   # DOWN\n                         (0, 10)     (10, 30)    (30, 60)    (60, 80)    (80, 90)];   # UP\njulia> animate_Ie_in_time(directory_to_process; angles_to_plot, colorrange=(1e5, 1e9), plot_Ietop=true)\n\n# Using nothing for empty panels:\njulia> angles_to_plot = [(180, 90)  nothing;\n                         (0, 45)    (45, 90)];\njulia> animate_Ie_in_time(directory_to_process; angles_to_plot)\n\nThe angles_to_plot is a matrix of tuples, where each tuple defines a pitch-angle range from 0° to 180° (where 180° is field-aligned down and 0° is field-aligned up). A panel will be created for each matrix element at the corresponding row/column position. Angles > 90° are labeled as \"DOWN\", angles < 90° as \"UP\". Use nothing for empty panels.\n\nThe limits of angles_to_plot need to match existing limits of the beams used in the simulation. E.g. if θ_lims = 180:-10:0 was used in the simulation, (150, 120) will be fine as 150° and 120° exist as limits, but (155, 120) will not as 155° does not exist as a limit.\n\nArguments\n\ndirectory_to_process: directory containing the simulation results (absolute or relative path).\n\nKeyword Arguments\n\nangles_to_plot = nothing: limits of the angles to plot as a matrix of tuples with angles                             in range 0-180°. Use nothing for empty panels. If the whole                             argument is nothing, uses the θ_lims grid from the simulation                             with down-flux on the first row and up-flux on the second row.\ncolorrange = nothing: limits for the colormap/colorbar as a tuple (min, max). If nothing,                         automatically computed as (maxvalue / 1e4, maxvalue) spanning                         4 orders of magnitude.\nsave_to_file = true: if true, saves the animation to a .mp4 file in the data directory.\nplot_Ietop = false: if true, also plots the precipitating Ie at the top of the                       ionosphere by loading it from the file Ie_top.mat.\nIetop_angle_cone = [170, 180]: angle cone (in degrees) for the precipitating Ie                       to plot.\n\n\n\n\n\n","category":"function"},{"location":"10-manual/15-folder_structure/#Folder-structure","page":"Folder structure","title":"Folder structure","text":"The package is structured as follows:\n\nAURORA.jl/\n├── data/\n│   └── <simulation_name>/...\n│   └── ...\n│\n├── docs/...\n│\n├── ext/\n│   ├── AURORA_viz.jl\n│   └── src/\n│       └── animations/\n│\n├── internal_data/\n│   ├── data_electron/\n│   ├── data_neutrals/\n│   ├── e_cascading/\n│   │   ├── N2/\n│   │   ├── O/\n│   │   └── O2/\n│   └── e_scattering/\n│\n├── scripts/\n│   ├── Control_script.jl\n│   ├── Control_script_SteadyState.jl\n│   ├── analysing/\n│   │   ├── Calculate_densities.jl\n│   │   └── Downsampling_fluxes.jl\n│   └── plotting/\n│       ├── Compare_Ie.jl\n│       ├── Compare_emission_rate.jl\n│       ├── Compare_ionization_rate.jl\n│       ├── Control_animations.jl\n│       ├── Plot_densities.jl\n│       ├── Plot_emission_rate.jl\n│       ├── Plot_ionization_rate.jl\n│       ├── Plot_phase_functions.jl\n│       └── Plot_setup.jl\n│\n├── src/\n│   ├── AURORA.jl\n│   ├── main.jl\n│   ├── setup.jl\n│   ├── input.jl\n│   ├── cascading.jl\n│   ├── scattering.jl\n│   ├── phase_functions.jl\n│   ├── energy_degradation.jl\n│   ├── matrix_building.jl\n│   ├── crank_nicolson.jl\n│   ├── steady_state.jl\n│   ├── analysis.jl\n│   ├── utilities.jl\n│   ├── iri/\n│   └── msis/\n│\n└── test/\n    ├── runtests.jl\n    └── ...\n\nThe folder data/ contains the subfolders where simulation results are saved. Each simulation run creates its own subfolder named after the simulation.\n\nThe folder docs/ contains all the necessary scripts to power this documentation.\n\nThe folder ext/ contains the package extensions. Currently it holds AURORA_viz, an extension that is loaded when visualization packages (such as Makie) are available, providing plotting and animation capabilities for simulation results.\n\nThe folder internal_data/ holds data used internally by the package:\n\ndata_electron/ and data_neutrals/ contain cross-section and atmospheric species data.\ne_cascading/ is where the electron cascading data produced by the simulations are cached for future use. The data are organized by species in the subfolders N2/, O2/ and O/. You should not need to venture into this folder.\ne_scattering/ contains precomputed electron scattering matrices.\n\nThe folder scripts/ contains scripts for users to run simulations and analyse or plot results:\n\nControl_script.jl and Control_script_SteadyState.jl are the main entry points for running time-dependent and steady-state simulations respectively.\nanalysing/ contains scripts for post-processing simulation outputs.\nplotting/ contains scripts for visualising simulation results.\n\nThe folder src/ contains the source code of the model. The iri/ and msis/ subfolders contain the interfaces to the IRI and MSIS atmospheric models respectively.\n\nThe folder test/ contains the automated tests for the package.","category":"section"},{"location":"#AURORA","page":"AURORA","title":"AURORA","text":"Documentation for AURORA.","category":"section"},{"location":"10-manual/05-installation/#Installation","page":"Installation","title":"Installation","text":"Clone the repository (e.g. with Git) or download and extract the .zip (available under the green code button on the GitHub page).\nOpen a terminal, move into the folder where AURORA was just installed, and start Julia with the command\n$> julia\nWe now need to install the packages required by AURORA. To do this, we need to activate and instantiate the repository environment using the following commands\njulia> using Pkg\njulia> Pkg.activate(\".\")\njulia> Pkg.instantiate() # this might take a while...\nAURORA is now ready to use!\n\nnote: Note\n\"Instantiating\" the environment will download and install dependencies in their correct version. This needs to be done only the first time you use AURORA.\n\"Activating\" the local environment will however have to be done everytime you start a new Julia session and want to use AURORA.\n\nwarning: Supported OS\nAURORA is developed on Linux and is thus only fully supported on Linux. It should also work fine on macOS. There might be some issues on Windows due to the use of the pymsis and iri2016 python packages which both call some fortran code under the hood (and thus bring all kind of issues related to making fortran compilers work on Windows).","category":"section"}]
}
